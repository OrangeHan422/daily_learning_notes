# BPF之巅

## 第一章 引言

### 1.1 BPF和eBPF是什么

简单来说，BPF提供了一种在各种内核事件和应用程序事件发生时运行一段小程序的机制（可以理解为钉子，钉在应用程序和内核事件之间）。

BPF由指令集、存储对象和辅助函数等几部分组成。由于它采用了虚拟指令集规范，因此也可将它视作一种虚拟机实现。这些指令由Linux内核的BPF运行时模块执行，具体来说，该运行时模块提供两种执行机制：一个解释器和一个将BPF指令动态转换为本地化指令的即时(JIT)编译器。在实际执行之前，BPF指令必须先通过验证器(verifer)的安全性检查，以确保BPF程序本身不会崩溃或者损坏内核。

扩展后的BPF(eBPF)，官方缩写依旧为BPF。实际上，在内核仍然只有一个执行引擎，即BPF，同时支持扩展后的BPF和“经典”的BPF

### 1.2 跟踪、嗅探、采样、剖析和可观测性都是什么

这些都是用来对分析技术和工具进行分类的术语

#### 跟踪(tracing)、嗅探

​	跟踪是基于事件的记录--这也是BPF工具所使用的监测方式。如Linux下的strace(1)，可以记录和打印系统调用事件的信息。也有像Linux中top(1)这种不跟踪事件，而是使用固定的计数器统计监测事件的频次，然后打印出摘要信息。一个**显著的特点**是，跟踪工具具备记录原始事件和事件元数据的能力。但是这类数据体量是庞大的，而BPF技术催生了可编程跟踪工具的出现，可以通过运行一段小程序来进行定制化的实时统计摘要或其他动作

​	常见工具有:strace,tcpdump以及Solaris系统中的各类嗅探器(snoop)

#### 采样(sampling)

​	通过获取全部观测量的子集来描绘目标的大致图像。也被称为profiling。有一个BPF工具就叫profile(8)，它基于计时器对运行中的代码进行定时采样。采样器的优点是，性能开销比跟踪工具小。缺点是，只提供了一个大致的图像，可能遗漏细节

#### 可观测性(observability)

​	通过全面观测来理解一个系统，可实现该目标的工具就可以归类为可观测性工具。包括跟踪、采样和基于固定计数器的工具。但是不包括基准测量(benchmark)工具，基准测量工具在系统上模拟业务负载，会更改系统的状态。BPF工具就属于可观测性工具，这些工具使用BPF技术进行可编程型跟踪分析。

> 总的来说，可观测性是跟踪采样的总体抽象

### 1.3 BCC、bpftrace和IO Visor

为了方便BPF程序的编写，在跟踪方面两个主流的前端：BCC和bpftrace

BCC（BPF编译器集合，BPF Compiler Collection）是最早用于开发BPF跟踪程序的高级框架。它提供了一个编写内核BPF程序的C语言环境，也为诸如Python、Lua和C++提供接口。也是libbcc和libbpf库的前身。这两个库提供了使用BPF程序对事件进行观测的库函数。BCC则是提供了70多个BPF工具。

bpftrace是一个新出现的前端，专门用于创建BPF工具的高级语言支持。bpftrace也是基于libbcc和libbpf库进行构建的

BCC和bpftrace的关系如图，bpftrace在编写功能强大的单行程序或者短小的脚步方面较强；BCC更适合开发复杂的脚本和作为后台进程使用，还可以调用其他的库支持(类比VS和vscode)：

![image-20240920144945199](./images/image-20240920144945199.png)

嵌入式方面有一个ply的BPF前端，较为轻量化且依赖最小化。部分bpftrace工具在转为ply语法后就可以使用ply执行，但是ply尚不成熟。

BCC和bpftrace都不在内核代码仓库中，均属于GitHub中名为IO Visor的Linux基金会项目

+ [ply](https://github.com/iovisor/ply)
+ [bpftrace](https://github.com/bpftrace/bpftrace)
+ [BCC](https://github.com/iovisor/bcc)

### 1.5 BPF跟踪的能见度

无需重启，当我们需要对内核组件、设备、应用库进行检查时，可以立即使用BPF工具对其现场直播

### 1.6 动态插桩：kprobes和uprobes

动态插桩技术：在生产环境对于正在运行的软件插入观测点的能力。在未启用时，软件不受任何影响，动态插桩开销为零。其中kprobes值得是内核函数插桩，uprobes是用户态函数插桩，在bpftrace中使用的动态插桩示例如下：

![image-20240920153840880](./images/image-20240920153840880.png)

### 1.7 静态插桩：tracepoint和USDT

>  tracepoint又称为内核跟踪点。

动态插桩技术有一大缺点：随着软件变更，被插桩的函数可能被重新命名，或者被移除。当内核或者应用软件升级后，BPF工具可能无法正常工作。这属于接口稳定性问题。并且在使用了编译器优化后，部分函数会被转换为内联函数(inline)函数，对于这些函数，就无法使用kprobes或者uprobes。

对于上述的问题，统一的解决方法是改用静态插桩技术。静态插桩会将稳定的事件名字编码到软件代码职工，由开发者进行维护。BPF工具支持内核的静态跟踪点插桩技术，也支持用户态的静态定义跟踪插桩技术USDT(user level statically defined tracing)。静态插桩技术的缺点显而易见，增加了开发者的维护成本，因此即使软件中存在静态插桩点，数量也十分有限。

上述缺点除非自己开发BPF工具，否则无需关注。如有需要，推荐先使用静态跟踪(跟踪点或者USDT)，不够用的话再使用动态插桩技术(kprobes或uprobes)。bpftrace中使用静态插桩技术的例子：

![image-20240920160047436](./images/image-20240920160047436.png)

### 1.8 初识bpftrace：跟踪open()

> 需要注意的是，当使用系统调用的跟踪点的时候，需要再内核编译的时候，打开`CONFIG_FTRACE_SYSCALLS`选项

使用bpftrace跟踪系统调用open(2)，可以使用一个现有的静态插桩点(syscall:sys_enter_open)，使用bpftrace可以写一个单行程序，在调用open的时候输出进程的名字和传递给open系统调用的文件名：

![image-20240920160848613](./images/image-20240920160848613.png)

其中bpftrace程序被定义在单引号内，编写后enter会立即编译执行，ctrl+c会结束同时移除BPF程序。也体现了BPF跟踪工具提供的按需插桩的工作方式：只在相关命令存活期间被激活。

open系统调用有很多的变体，可以通过命令选项`-l`使用统配符进行跟踪列出所有和open相关的跟踪点

![image-20240920161351459](./images/image-20240920161351459.png)

实际上，openat这个变体使用的频率可能更高，可以使用bpftrace来验证一下：

![image-20240920161511400](./images/image-20240920161511400.png)

上述的计算信息都是在内核态下高效计算出来的，当bpftrace定义的程序过长的时候，可以将其制作为一个脚本进行执行。

bpftrace提供了一个跟踪所有系统调用开始和结束位置的程序opensnoop.bt

![image-20240920162122721](./images/image-20240920162122721.png)

### 1.9 再回到BCC：追踪open()

BCC版本的opensnoop

![image-20240920162336293](./images/image-20240920162336293.png)

BCC提供的工具一般会提供更加复杂的功能：

![image-20240920162522759](./images/image-20240920162522759.png)

这也就体现了BCC和bpftrace的差异：BCC自带工具很多，可以直接上手使用；而bpftrace则语法简单，更适合定制化开发

## 第二章 技术背景

### 2.1 图释BPF

![image-20240920173010953](./images/image-20240920173010953.png)

### 2.2 BPF

BPF的工作方式：最终用户通过BPF虚拟机的指令集（也称为BPF字节码）定义过滤器表达式，然后传递给内核，有**解释器**执行。因此包过滤式在内核中直接执行的，避免了向用户态进程复制每个数据包。同时，BPF还提供了安全保障，用户自定义的过滤器首先需要通过安全性验证。tcpdump就使用了BPF过滤，其简要流程如下：

![image-20240920173645165](./images/image-20240920173645165.png)

使用tcpdump -d 参数可以打印出过滤器表达式的BPF指令：

![image-20240920173749734](./images/image-20240920173749734.png)

### 2.3 eBPF

Linux运行时各模块的架构如下图，该图展示了BPF指令如何通过BPF验证器验证，再有BPF虚拟机执行。BPF虚拟机包括一个解释器以及一个JIT(及时 just in time)编译器:JIT负责生成处理器可直接执行的机器指令。验证器则拒绝不安全的指令。![image-20240920174523589](./images/image-20240920174523589.png)

BPF可以通过辅助函数获取内核状态，利用BPF映射表进行存储。BPF程序在特定时间发生时执行，包括动态插桩（kprobes,uprobes）以及静态插桩(跟踪点)

#### 2.3.1 为什么性能工具需要BPF

BPF的与众不同之处在于，同时具备了高效率和生产环境安全性的特点，并且已经内置在了Linux内核中，有了BPF就可以直接使用BPF工具，无需新增内核组件。

#### 2.3.3 编写BPF程序

进行BPF编程的前端工具，从低级到高级排列如下：

+ LLVM：可以使用C语言或者LLVM中间表示形式(Intermediate Representation)进行编写，然后再编译为BPF，LLVM自带优化器，可以对它生成的BPF指令进行效率和体积上的优化
+ BCC：允许使用C语言编写BPF程序。内部实现仍然是使用LLVM中间表示形式和一个LLVM库来实现BPF编译
+ bpftrace：提供自己的高级语言。内部实现仍然是使用LLVM中间表示形式和一个LLVM库来实现BPF编译

虽然很少使用到直接通过BPF指令集进行编程的情况，但是在使用工具遇到问题的时候，会有查看指令的需求。接下来两个小节通过bpftool以及bpftrace进行示例

#### 2.3.4 使用BPF查看指令集：bpftool

Linux4.15添加了bpftool这个工具，可以用来查看和操作BPF对象，包括BPF程序和对应的映射表。源码位于Linux源码的tools/bpf/bpftool中

bpftools的默认输出展示了所操作的BPF对象：

![image-20240925085939087](./images/image-20240925085939087.png)

对于每一个对象，都有一个专门的帮助文档：

![image-20240925090049265](./images/image-20240925090049265.png)

**bpftools perf**显示了哪些BPF程序正在通过perf_event_open()进行挂载：

![image-20240925090246767](./images/image-20240925090246767.png)

![image-20240925090552353](./images/image-20240925090552353.png)![image-20240925090558677](./images/image-20240925090558677.png)

以上输出有3个不同的PID，分属不同的BPF程序

+ PID 1765 是Vecotr BPF PMDA大理，用来做实例性能分析(细节见17章)
+ PID 21993 是bpftrace版本的biolatency。它显示使用两个uprobes（用户态插桩）,即bpftrace中的BEGIN和END探针，还有两个kprobes(内核态插桩)用于对块IO的起始结束进行插桩（第9章有该程序的源码）
+ PID 25440 是BCC版本的biolatency，它正在对另一个块IO的起始函数进行插桩

offset字段显示了被插桩对象的偏移量。对于bpftrace，偏移量1781920匹配了bpftrace二进制文件中的BEGIN_trigger函数，偏移量1781927匹配了END_trigger函数(可以使用readelf -s bpftrace来进行验证)

prog_id是BPF程序ID，可以使用该命令进行打印：

```shell
bpftool prog show 
```

![image-20240925091428245](./images/image-20240925091428245.png)

输出以程序ID开始（262 263），示例中是BCC的kprobe程序，该程序中带有BTF(BPF Type Format)信息，这可以从上面的输出显示的btf_id看出来。此时仅需要知道BTF是BPF版本的调试信息就可以了。

bpftool prog dump xlated

每个BPF程序都可以通过它的ID被打印出来。xlated模式将BPF指令翻译为汇编指令打印出来。示例中为程序234、bpftrace块IO完成跟踪程序的输出：

![image-20240926085137293](./images/image-20240926085137293.png)![image-20240926085143213](./images/image-20240926085143213.png)

上述输出显示了可被BPF调用的受限的内核辅助函数之一：bpf_probe_read()

以下为比较上述输出（非黑体汇编）和观测块IO完成事件的程序（黑体）输出，该程序基于BTF编译，ID是263：

![image-20240926085522511](./images/image-20240926085522511.png)

如果程序中包含了BTF信息，那么可以使用linum修饰符在输出中增加源代码文件和行信息（使用黑体标记）

![image-20240926085728804](./images/image-20240926085728804.png)

使用opcodes可以输出包含BPF指令的opcode(黑体表示，操作码)：

![image-20240926090017965](./images/image-20240926090017965.png)

修饰符visual,可以以DOT格式输出控制流信息，支持使用外部可视化软件打开。以下例子使用的是GraphVix软件和其绘制有向图工具dot(1):

![image-20240926090219035](./images/image-20240926090219035.png)

以下为使用GraphVix中的osage对BPF程序可视化执行的结果：

![image-20240926090400653](./images/image-20240926090400653.png)

bpftool prog dump jited

prog dump jited子命令显示了经过JIT编译之后的机器码。示例为x86_64体系结构下BCC的块IO完成跟踪程序：

![image-20240926090641470](./images/image-20240926090641470.png)![image-20240926090649981](./images/image-20240926090649981.png)

bpftool btf

bpftool可以打印BTF的ID，如BTF ID 5 是BCC的块IO的完成事件的输出：

![image-20240926091136016](./images/image-20240926091136016.png)![image-20240926091143860](./images/image-20240926091143860.png)

#### 2.3.5 使用bpftrace查看BPF指令集

tcpdump 的-d参数可以输出BPF指令，bpftrace也可以通过-v/-d参数达到该效果：

![image-20240926091516099](./images/image-20240926091516099.png)

大多数人不是设计到BPF指令层次的修改或者错误排查，这些事情应该交给社区来管理，大咖也可以直接向社区提供补丁

#### 2.3.6 BPF API

**BPF辅助函数**

BPF不允许任意调用内核函数，内核为BPF提供了可以调用的辅助函数，以下为部分辅助函数：

![image-20240926180027805](./images/image-20240926180027805.png)![image-20240926180037270](./images/image-20240926180037270.png)

辅助函数中的“current”是指的是当前正在运行的线程，也就是当前正在CPU上执行任务的线程。

在内核源文件的头文件中，一般会为函数提供注释，而Linux的源码文件可以从一些网站上浏览

**bpf_probe_read()**

bpf_probe_read()是一个十分重要的函数。BPF中内存访问权限仅限于BPF寄存器和栈空间以及通过辅助函数访问的BPF映射表。如果需要访问其他内存（如BPF之外的其他内核地址），就必须通过bpf_probe_read()来读取。

该函数会进行安全性检查并禁止缺页中断的发生，以保证在probe上下文中不会发生缺页中断。

此外，该函数还可以将用户空间的内容读取到内核空间。

**BPF系统调用命令**

部分系统调用：

![image-20240927090701521](./images/image-20240927090701521.png)

其中第一列可以作为bpf系统调用的第一个参数进行传递，使用strace(1)可以看到。如下例可以看到BCC版本的execsnoop(8)工具用到了那些bpf(2)系统调用：

![image-20240927090957974](./images/image-20240927090957974.png)![image-20240927091010505](./images/image-20240927091010505.png)

这里需要**注意**，应该避免直接使用strace，因为当前的ptrace()实现会严重降低目标进程的运行速度----->性能下降为不足原来的%1。这里使用仅仅是因为他已经支持bpf(2)系统调用的参数翻译，即将一个数字翻译为一个可读的字符串

**BPF程序类型**

不同的BPF程序类型定义了BPF程序可以挂载的事件类型，以及事件的参数。主要用于跟踪用途的BPF程序类型如下：

![image-20240927091728222](./images/image-20240927091728222.png)

在bpf.h中还有一些程序类型用于网络以及其他用途，如下：

![image-20240927091829753](./images/image-20240927091829753.png)

**BPF映射表类型**

定义了不同类型的映射表数据结构：

![image-20240927092001965](./images/image-20240927092001965.png)

#### 2.3.7 BPF并发控制

在Linux5.1 增加辅助函数spin lock之前，BPF还不支持并发控制。

术语丢失的更新：在进行跟踪的时候，并行的多个线程可能会同时对映射表数据进行查找和更新，造成一个线程破坏另一个线程的数据，即由当前的读和写发生了重叠造成的（本质上还是数据竞态）

跟踪程序使用的BCC和bpftrace前端，使用了per-CPU的哈希和数组映射类型，以尽可能的避免冲突。他们为每个*逻辑*CPU创建了独享的数据结构实例，避免了并行的线程对共享的位置进行更新。例如，一个对事件进行计数的映射表，可以通过对每个CPU上的映射表数据结构进行更新，然后再将每个CPU对应的映射表中的值相加，以得到事件总数。

具体的例子，对单行bpftrace程序使用per-CPU哈希映射来计数：

![image-20240927093210725](./images/image-20240927093210725.png)

而该单行bpftrace程序使用了普通的哈希映射来计数：

![image-20240927093252978](./images/image-20240927093252978.png)![image-20240927093303638](./images/image-20240927093303638.png)

如果在一个8-CPU系统上同时运行这两个程序，结果如下：

![image-20240927093353545](./images/image-20240927093353545.png)

可以看到，普通的哈希映射大概会丢掉0.01%的统计值

除了每个CPU专用的映射之外，还有其他一些机制进行并发控制，包括互斥的相加操作（BPF_XADD）、“映射中的映射”机制（可以对整个映射进行原子更新的操作），以及BPF的自旋锁等机制。使用bpf_map_update_elem()对常规的哈希和LRU映射进行操作也是原子性的，不会产生写竞争。在Linux5.1中引入的自旋锁，可以通过bpf_spin_lock()和bpf_spin_unlock()进行控制。

#### 2.3.8 BPF sysfs接口
