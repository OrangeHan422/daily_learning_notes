> 该笔记记录工作中学习开发分布式性能监控项目中学习到的技能和知识点。

# Makefile

## 基础

makefile的三要素：依赖，目标，命令

```makefile
目标:依赖
	命令  //注意前面是tab
```

makefile支持增量编译,make会通过文件的时间戳判断是否需要进行增量编译以及对哪些文件进行增量编译

查看版本

```shell
make -v
```

简单示例：

```makefile
all:
	echo "Hello World"
```

执行结果：

```bash
$make
echo "Hello World"
Hello World

$make all
echo "Hello World"
Hello World

$make test
make: *** No rule to make target `test'. Stop.
```

可以为makefile加入test规则：

```makefile
all:
	echo "Hello World"
test:
	echo "Just for test!"
```

注意，make命令默认执行的是第一个规则，该示例中是all，但是对规则名称没有要求:

```bash
$make
echo "Hello World"
Hello World

$make test
echo "Just for test!"
Just for test!
```

我们可以对makefile做出更改，使得终端不输出执行的命令，。即在命令前加入`@`：

```makefile
all:
	@echo "Hello World"
test:
	@echo "Just for test!
```

```bash
$make
Hello World
```

再次更改makefile，使all依赖于test（该示例中，test也称之为all的*先决条件*）：

```makefile
all: test
	@echo "Hello World"
test:
	@echo "Just for test!"
```

```bash
$make
Just for test!
Hello World

$make test
Just for test!
```

对于规则，可以由多个目标名称，以空格隔开

```c++
all test:
	@echo "Hello World"
```

```bash
$make
Hello World

$make test
Hello World
```

### 简单应用：

**foo.c**:

```c
#include <stdio.h>
void foo ()
{
	printf ("This is foo   ()!\n");
}
```

**main.c**

```c
extern void foo();
int main ()
{
	foo();
	return 0;
}
```

**Makefile**

```makefile
all: main.o foo.o
	gcc -o simple main.o foo.o
main.o: main.c
	gcc -o main.o -c main.c
foo.o: foo.c
	gcc -o foo.o -c foo.c
clean:
	rm simple main.o foo.o
```

执行流程：

```bash
$make
gcc -c main.c -o main.o
gcc -c foo.c -o foo.o
gcc -o simple main.o foo.o

$./simple
This is foo ()!

$make clean
rm simple main.o foo.o
```

即使更改了规则的目标名，也不会影响makefile的增量编译：

```makefile
simple: main.o foo.o
	gcc -o simple main.o foo.o
main.o: main.c
	gcc -o main.o -c main.c
foo.o: foo.c
	gcc -o foo.o -c foo.c
clean:
	rm simple main.o foo.o
```

```bash
$make
gcc -c main.c -o main.o
gcc -c foo.c -o foo.o
gcc -o simple main.o foo.o

$make
make: `simple' is up to date.
```

### 假目标

加入touch了一个clean文件，在上述实例中，clean文件没有改变，make就永远不会像我们期待的那样执行rm指令。解决该问题的方法是使用**假目标**，即声明目标名并且加上`.PHONY:`,如：

```makefile
.PHONY: clean
simple: main.o foo.o
	gcc -o simple main.o foo.o
main.o: main.c
	gcc -o main.o -c main.c
foo.o: foo.c
	gcc -o foo.o -c foo.c
clean:
	rm simple main.o foo.o
```

### 变量

简单示例：

```makefile
.PHONY: clean
CC = gcc
RM = rm
EXE = simple
OBJS = main.o foo.o
$(EXE): $(OBJS)
	$(CC) -o $(EXE) $(OBJS)
main.o: main.c
	$(CC) -o main.o -c main.c
foo.o: foo.c
	$(CC) -o foo.o -c foo.c
clean:
	$(RM) $(EXE) $(OBJS)
```

变量的命名类似PYTHON，直接命名就可以。而变量的使用则是以`$(变量名)`的形式（类似预处理，直接替换文本）。

#### 自动变量

当目标或者依赖名称改变时，往往需要更改很多命令。对此，Makefile提供了自动变量(根据规则的上下文推导)：

- **$@**用于表示一个规则中的目标。当我们的一个规则中有多个目标时，$@所指的是其中**任何造成命令被运行的目标。**
- **$^**则表示的是规则中的所有先决条件。
- **$<**表示的是规则中的第一个先决条件。

需要注意的是，在 Makefile 中‘$’具有特殊的意思，因此，如果想采用 echo 输出‘$’，则必需用两个连着的‘$’。还有就是，$@对于 Shell 也有特殊的意思，我们需要在“$$@”之前再加一个脱字符‘\’。

简单示例：

```makefile
.PHONY: all
all: first second third
	@echo "\$$@ = $@"
	@echo "$$^ = $^"
	@echo "$$< = $<"
first second third:
```

```bash
$make
$@ = all				//目标
$^ = first second third	//依赖
$< = first				//首个依赖
```

对此可以对simple的makfile进行更改：

```c++
.PHONY: clean
CC = gcc
RM = rm
EXE = simple
OBJS = main.o foo.o
$(EXE): $(OBJS)
	$(CC) -o $@ $^				//原命令$(CC) -o $(EXE) $(OBJS)
main.o: main.c
	$(CC) -o $@ -c $^			//原命令：$(CC) -o main.o -c main.c
foo.o: foo.c
	$(CC) -o $@ -c $^			//原命令：$(CC) -o foo.o -c foo.c
clean:
	$(RM) $(EXE) $(OBJS)
```

#### 特殊变量

+ MAKE变量：代表make命令名，主要是为了增加可移植性

  ```makefile
  .PHONY: all
  all:
  	@echo "MAKE = $(MAKE)"
  ```

  ```bash
  $make
  MAKE = make
  ```

+ MAKECMDGOALS:make的目标名

  ```makefile
  Makefile
  .PHONY: all clean
  all clean:
      @echo "\$$@ = $@"
      @echo "MAKECMDGOALS = $(MAKECMDGOALS)"
  ```

  ```bash
  $make
  $@ = all
  MAKECMDGOALS =
  
  $make all
  $@ = all
  MAKECMDGOALS = all
  
  $make clean
  $@ = clean
  MAKECMDGOALS = clean
  
  $make all clean
  $@ = all
  MAKECMDGOALS = all clean
  $@ = clean
  MAKECMDGOALS = all clean
  ```

#### 变量类别

makefile提供了**递归扩展变量**的操作：

```makefile
.PHONY: all
foo = $(bar)
bar = $(ugh)
ugh = Huh?
all:
	@echo $(foo)
```

```bash
$make
Huh?
```

其实还是类似预处理的操作，核心还是变量的使用，需要注意的是防止死循环：

```makefile
CFLAGS = $(CFLAGS) -O	//死循环
```

同时makefile也提供了`:=`形式的**简单扩展变量**，这种形式的变量只会进行一次扫描和替换

```makefile
.PHONY: all
x = foo
y = $(x) b
x = later
xx := foo
yy := $(xx) b
xx := later
all:
	@echo "y = $(y), yy = $(yy)"
```

```bash
$make
y = later b, yy= foo b
```

最后makefile也提供了`?=`形式的条件赋值（即当前变量如果没有定义的话就进行赋值，否则无操作）：

```makefile
.PHONY: all
foo = x
foo ?= y
bar ?= y
all:
	@echo "foo = $(foo), bar = $(bar)"
```

```bash
$make
foo = x, bar = y
```

综上，我们可以书写可扩展，易读性强的makefile:

```makefile
.PHONY: all
objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o
all:
	@echo $(objects)
```

```bash
$make
main.o foo.o bar.o utils.o another.o
```

#### 其他方式更改变量值

+ 执行make 并指定值，如:

  ```bash
  $make foo=haha
  foo = haha, bar = x
  ```

+ 通过export导入：

  ```bash
  $make
  foo = x, bar = y
  
  $export bar=x
  
  $make
  foo = x, bar = x
  ```

#### 高级变量引用功能

可以对变量赋值的同时完成后缀替换的操作。语法为`$(变量名:原后缀名=目标后缀名)`

```makefile
.PHONY: all
foo = a.o b.o c.o
bar := $(foo:.o=.c)
all:
	@echo "bar = $(bar)"
```

```bash
$make
bar = a.c b.c c.c
```

#### override

和C++中的override正好反过来，意思是这个变量不允许其他值覆盖：

```makefile
.PHONY: all
override foo = x
all:
	@echo "foo = $(foo)"
```

```bash
$make foo=haha
foo = x
```

### 模式

其实就是使用`%`作为通配符，如：

```makefile
.PHONY: clean
CC = gcc
RM = rm
EXE = simple
OBJS = main.o foo.o
$(EXE): $(OBJS)
	$(CC) -o $@ $^
%.o: %.c				//	main.o: main.c
	$(CC) -o $@ -c $^   //      gcc -o main.o -c main.c
                        //  foo.o: foo.c
                        //      gcc -o foo.o -c foo.c

clean:
	$(RM) $(EXE) $(OBJS)
```

### 函数

#### addprefix函数

为字符串中每个子串前加上一个前缀：`$(addprefix prefix,names...)`

```makefile
.PHONY: all
without_dir = foo.c bar.c main.o
with_dir := $( addprefix objs/, $(without_dir))
all:
	@echo $(with_dir)
```

```bash
$make
objs/foo.c objs/bar.c objs/main.o
```

#### filter函数

根据模式得到满足模式的字符串（简化正则）：`$(filter pattern...,text)`

```makefile
.PHONY: all
sources = foo.c bar.c baz.s ugh.h
sources := $(filter %.c %.s, $(sources))
all:
	@echo $(sources)
```

```bash
$make
foo.c bar.c baz.s		//可以看到过滤掉了.h文件
```

#### filter-out函数

过滤掉满足模式的字符串：`$(filter-out pattern...,text)`

```makefile
.PHONY: all
objects = main1.o foo.o main2.o bar.o
result = $(filter-out main%.o, $(objects))
all:
	@echo $(result)
```

```bash
$make
foo.o bar.o 	//过滤掉了满足main%.o模式的文件
```

#### patsubst 函数

根据模式进行字符串替换：`$(patsubst pattern,replacement,text)`

```makefile
.PHONY: all
mixed = foo.c bar.c main.o
objects := $(patsubst %.c, %.o, $(mixed))  # 将.c文件替换为.o文件
all:
	@echo $(objects)
```

```bash
$make
foo.o bar.o main.o
```

#### strip函数

去除字符串中多余空格：`$(strip string)`

```makefile
original = foo.c   bar.c
stripped := $(strip $(original))
all:
    @echo "original = $(original)"
    @echo "stripped = $(stripped)"
```

```bash
$make
original = foo.c   bar.c
stripped = foo.c bar.c
```

#### wildcard函数

通配符函数：`$(wildcard pattern)`

```makefile
.PHONY: all
SRCS = $(wildcard *.c)
all:
	@echo $(SRCS)
```

```bash
$make
bar.c foo.c main.c
```

# CMake

粗略的说，CMake就是生成编译配置文件，在Linux上就是生成makefile。

构建工程文件需要编写的是CMakeList.txt

## 第一步 起点

### 练习1 最简单的CMake项目

**`CMakeLists.txt`**

```cmake
# TODO 1: 设置CMake最低版本要求为 3.10
cmake_minimum_required(VERSION 3.10)

# TODO 2: 创建一个名为Tutorial的项目
project(Tutorial)

# TODO 3: 为项目添加一个叫做 Tutorial 的可执行文件
# Hint: 一定要指定源文件 tutorial.cxx
add_executable(Tutorial tutorial.cxx)
```

**要点**

①cmake_minimum_required

用于指定所需cmake最低版本

用法与示例：

```cmake
# 用法
cmake_minimum_required(VERSION <版本号>)
# 示例
cmake_minimum_required(VERSION 3.10)
```

如果当前使用的cmake版本低于所指定的版本，则会报错并且终止执行。

②project

指定项目名称

用法与示例：

```cmake
# 用法
project(<项目名>)
# 示例 指定项目名称为Tutorial
project(Tutorial)
```

③add_executable

利用指定的源文件在项目中添加可执行文件

用法与示例：

```cmake
# 用法 源文件可以有多个，用空格隔开
add_executable(<可执行文件名> <源文件列表>)
# 示例 可执行文件名为Tutorial，用到的源文件为tutorial.cxx
add_executable(Tutorial tutorial.cxx)
```

④cmake命令常用执行方法

```bash
# 用法
cmake -G <生成器名称> <CMakeLists.txt所在的目录>

# Linux下一般流程,进入项目根目录后
mkdir build;cd build;cmake ..
```

如果使用默认生成器，则-G这部分可以省略，具体支持哪些生成器可以用cmake --help查看

> 扩展：设置环境变量CMAKE_GENERATOR可以指定默认生成器，简化cmake命令的执行

### 练习2 指定C++标准

**`CMakeLists.txt`**

```cmake
# TODO 1: 设置CMake最低版本要求为 3.10
cmake_minimum_required(VERSION 3.10)

# TODO 2: 创建一个名为Tutorial的项目
project(Tutorial)

# TODO 7: 用上面project命令将项目版本设为 1.0

# TODO 6: 设置变量 CMAKE_CXX_STANDARD 为 11
#          CMAKE_CXX_STANDARD_REQUIRED 为 True
set(CMAKE_CXX_STANDARD 26)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# TODO 8: 用 configure_file 复制 TutorialConfig.h.in 生成
#         TutorialConfig.h

# TODO 3: 为项目添加一个叫做 Tutorial 的可执行文件
# Hint: 一定要指定源文件 tutorial.cxx
add_executable(Tutorial tutorial.cxx)
```

**要点**

①set

用于给变量设置值

用法与示例：

```cmake
# 用法
set(<变量名> <变量值>)
# 示例
set(CMAKE_CXX_STANDARD 26)
set(SRC_DIR /home/src)
```

②CMAKE_CXX_STANDARD

变量，用于指定C++标准

用法与示例：

```cmake
# 用法 截止2023/6 std_num∈{98,11,14,17,20,23,26}
set(CMAKE_CXX_STANDARD <std_num>)
# 示例
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD 17)
```

> 在C++中可以通过输出__cplusplus查看当前编译器所用的标准
>
> | __cplusplus的值 | 对应的C++标准 |
> | --------------- | ------------- |
> | 199711          | C++98         |
> | 201103          | C++11         |
> | 201402          | C++14         |
> | 201703          | C++17         |
> | 202002          | C++20         |
> | 202100          | C++23         |

③CMAKE_CXX_STANDARD_REQUIRED

变量，如果设置为True，则通过CMAKE_CXX_STANDARD设置的C++标准是必需的，如果编译器不支持该标准则会输出错误提示信息。如果不设置或者设置为False，则CMAKE_CXX_STANDARD设置的C++标准不是必需的，如果编译器不支持对应的标准，则会使用上一个版本的标准进行编译。

用法与示例：

```cmake
set(CMAKE_CXX_STANDARD_REQUIRED True)
```

### 练习3 添加版本号和配置头文件

有些时候需要让源代码能访问CMakeLIsts.txt当中的数据，比如说在CMakeLists.txt中定义版本号之后，希望能在源程序中对版本号进行输出。本节内容为如何让源代码中能访问CMakeLists.txt中的变量数据。

```cmake
CMakeLists.txt
# TODO 1: 设置CMake最低版本要求为 3.10
cmake_minimum_required(VERSION 3.10)

# TODO 2: 创建一个名为Tutorial的项目
project(Tutorial VERSION 11.25)

# TODO 7: 用上面project命令将项目版本设为 1.0

# TODO 6: 设置变量 CMAKE_CXX_STANDARD 为 11
#          CMAKE_CXX_STANDARD_REQUIRED 为 True
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# set(STR_TEST "Hello World")

# TODO 8: 用 configure_file 复制 TutorialConfig.h.in 生成
#         TutorialConfig.h
configure_file(TutorialConfig.h.in TutorialConfig.h)

# TODO 3: 为项目添加一个叫做 Tutorial 的可执行文件
# Hint: 一定要指定源文件 tutorial.cxx
add_executable(Tutorial tutorial.cxx)

# TODO 9: 用 target_include_directories 添加头文件搜索目录 ${PROJECT_BINARY_DIR}
# PUBLIC PRIVATE INTERFACE
target_include_directories(Tutorial PUBLIC ${PROJECT_BINARY_DIR})
TutorialConfig.h.in
#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@
```

**要点**

〇project第二种用法

定义项目名和版本号

```cmake
project(Tutorial VERSION 2.15)
```

①configure_file

将输入文件复制为输出文件，并把其中的变量引用替换为CMakeLists.txt中定义的变量，如果变量未定义，则替换为空串。输入文件中的变量引用方式为**@@变量名@@**或者**${变量名}**。

输入文件(.h.in)默认路径为CMakeLists.txt所在的路径，输出文件(.h)的路径默认为cmake生成文件所在的路径。

用法与示例：

```cmake
# 用法
configure_file(<inputfile> <outputfile>)
# 示例
configure_file(TutorialConfig.h.in TutorialConfig.h)
```

在输出文件(.h)中，用宏定义的方式对变量进行定义

```cmake
#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR ${Tutorial_VERSION_MINOR}

// 因为CMakeLists.txt中定义的字符串都是裸的，所以如果一个变量的值为字符串，需要用双引号包起来
#define STR_VAR "@STR_VAR@"
```

上述定义中@Tutorial_VERSION_MAJOR@、${Tutorial_VERSION_MINOR}、@STR_VAR@在输出文件中会被替换为CMakeLists.txt中定义的对应变量值。

 

②target_include_directories

给指定的目标添加头文件搜索路径。

用法与示例：

```cmake
# 用法
target_include_directories(<target> <INTERFACE|PUBLIC|PRIVATE> <dir1 dir2 ...>)

# 示例
target_include_directories(Tutorial PUBLIC ${PROJECT_BINARY_DIR})
```

> PROJECT_BINARY_DIR:二进制文件存储目录（即可执行文件生成位置）

③_VERSION_MAJOR

版本号第一个组成部分。该变量为cmake自动定义的一个变量，不需要手动定义，值来自于project的定义。其中为用**project**定义的项目名。

> 一般形式为：项目名称_VERSION_MAJOR,或者直接PROJECT_VERSION_MAJOR

④_VERSION_MINOR

版本号第二个组成部分。该变量为cmake自动定义的一个变量，不需要手动定义，值来自于project的定义。其中为用**project**定义的项目名。

> 一般形式为：项目名称_VERSION_MINOR,或者直接PROJECT_VERSION_MINOR

## 第二步 加个库

### 练习1 创建库文件

前面的练习当中创建了可执行文件。本节将学习如何创建库文件以及库文件的使用 。同时也将练习将一个项目划分为多个子目录的方法。

```cmake
CMakeLists.txt
cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# TODO 7: Create a variable USE_MYMATH using option and set default to ON


# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)

# TODO 8: Use list() and APPEND to create a list of optional libraries
# called  EXTRA_LIBS and a list of optional include directories called
# EXTRA_INCLUDES. Add the MathFunctions library and source directory to
# the appropriate lists.
#
# Only call add_subdirectory and only add MathFunctions specific values
# to EXTRA_LIBS and EXTRA_INCLUDES if USE_MYMATH is true.

# TODO 2: Use add_subdirectory() to add MathFunctions to this project

add_subdirectory(MathFunctions)




# add the executable
add_executable(Tutorial tutorial.cxx)

# TODO 9: Use EXTRA_LIBS instead of the MathFunctions specific values
# in target_link_libraries.

# TODO 3: Use target_link_libraries to link the library to our executable
# 即三方库名，三方库名在三方库目录中的CMakeLists中使用add_library定义
# 在g++命令中相当于-lMathFunctions
target_link_libraries(Tutorial PUBLIC MathFunctions)

# TODO 4: Add MathFunctions to Tutorial's target_include_directories()
# Hint: ${PROJECT_SOURCE_DIR} is a path to the project source. AKA This folder!

# TODO 10: Use EXTRA_INCLUDES instead of the MathFunctions specific values
# in target_include_directories.

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
# 该步骤添加的是头文件搜索路径，即include_dir
# 在g++命令中相当于-I /path/build -I path/MathFunctions
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           "${PROJECT_SOURCE_DIR}/MathFunctions"	
                           )

# MathFunctions/CMakeLists.txt，即三方库中的cmake配置文件
# TODO 1: Add a library called MathFunctions
# Hint: You will need the add_library command
# 通过mysqrt.cxx生成lMathFunctions.a静态库
add_library(MathFunctions mysqrt.cxx)
```

**要点**

①add_subdirectory

为当前项目添加子目录。子目录当中必须包含一个CMakeLists.txt文件，其中可以不写cmake_minimum_required与project。

用法与示例：

```cmake
# 用法
add_subdirectory(<source_dir>)
# 示例
add_subdirectory(MathFunctions)
```

②target_link_libraries

为指定目录指定链接库。

用法与示例：

```cmake
# 用法
target_link_libraries(<target> ... <item>... ...)
# 示例
target_link_libraries(Tutorial PUBLIC MathFunctions)
```

③PROJECT_SOURCE_DIR

最后一次调用project的CMakeLists.txt文件所在的目录。

④add_library

用指定的源文件生成库文件。

用法与示例：

```cmake
# 用法
add_library(<name> [<source>...])
# 示例
add_library(MathFunctions mysqrt.cxx MathFunctions.h)
```

 

 

### 练习2 库文件可选编译

本节内容为设置库文件（子目录）可选编译。

需要注意的是，除了CMakeLists文件需要修改，cmake生成的配置头文件TutorialConfig.h.in也要添加option设置的宏(需要使用`#cmakedefine XXX`定义宏)，在源程序中也要添加宏判断区分使用不同库

```cmake
cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# TODO 7: Create a variable USE_MYMATH using option and set default to ON
# 创建cmake的布尔值，参数分别为变量名，描述，ON|OFF。
# 在进行cmake构建工程的时候，可以使用-DUSE_MYMATH=ON|OFF 来控制生成makefile
option(USE_MYMATH "Use My Math?" OFF)

# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)

# TODO 8: Use list() and APPEND to create a list of optional libraries
# called  EXTRA_LIBS and a list of optional include directories called
# EXTRA_INCLUDES. Add the MathFunctions library and source directory to
# the appropriate lists.
#
# Only call add_subdirectory and only add MathFunctions specific values
# to EXTRA_LIBS and EXTRA_INCLUDES if USE_MYMATH is true.

# TODO 2: Use add_subdirectory() to add MathFunctions to this project
if(USE_MYMATH)
    add_subdirectory(MathFunctions)
    # 可选三方库APPEND至EXTRA_LIBS中
    list(APPEND EXTRA_LIBS MathFunctions) 
    # 可选三方库头文件目录APPEND至EXTRA_INCLUDES中
    list(APPEND EXTRA_INCLUDES "${PROJECT_SOURCE_DIR}/MathFunctions")
endif()



# add the executable
add_executable(Tutorial tutorial.cxx)

# TODO 9: Use EXTRA_LIBS instead of the MathFunctions specific values
# in target_link_libraries.

# TODO 3: Use target_link_libraries to link the library to our executable
# 添加的三方库都在EXTRA_LIBS变量中存储，EXTRA_LIBS是一个cmake的list
target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})

# TODO 4: Add MathFunctions to Tutorial's target_include_directories()
# Hint: ${PROJECT_SOURCE_DIR} is a path to the project source. AKA This folder!

# TODO 10: Use EXTRA_INCLUDES instead of the MathFunctions specific values
# in target_include_directories.

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                   # 三方库的头文件目录都在EXTRA_INCLUDES中存储，EXTRA_INCLUDES是一个cmake的list
                           "${EXTRA_INCLUDES}"
                           )
```

**要点**

①option

提供一个布尔变量，可以让用户自行选择。

用法与示例：

```cmake
# 用法
option(<variable> "<help_text>" [value])
# 示例
option(USE_MYMATH "Use MyMath" ON)
```

`value`值为`ON`或`OFF`，默认值为`OFF`。

在执行配置时，可以用`-D`来指定值，例如

```bash
cmake . -DUSE_MYMATH=OFF
```

②if() & endif()

条件判断开始与结束。

语法：

```cmake
if(<condition>)
  <commands>
elseif(<condition>)
  <commands>
else()
  <commands>
endif()
```

| <condition>判断为真的值 | <condition>判断为假的值     |
| ----------------------- | --------------------------- |
| 1                       | 0                           |
| ON                      | OFF                         |
| TRUE                    | FALSE                       |
| YES                     | NO                          |
| Y                       | N                           |
| 其他非0数               | IGNORE                      |
|                         | NOTFOUND或以-NOTFOUND结尾的 |
|                         | 值不是判断为真的字符串      |

③list

列表操作。详细操作见[list](https://gitee.com/unlimited13/cpp/blob/master/cmake/cmake.md#)，这里只讲用到的APPEND操作。将一些元素追加到已有的列表当中。如果列表变量还未定义，则会当做空列表处理。

语法与示例：

```cmake
# 语法
list(APPEND <list> [<element> ...])
# 示例 将MathFunctions追加到EXTRA_LIBS当中
list(APPEND EXTRA_LIBS MathFunctions)
```

④cmakedefine

用法与#define相同，用在configure_file的输入文件当中进行宏定义。

不同点在于，#define本身就是C/C++当中的宏定义，所以不论对应的变量是否在CMakeLists.txt中有定义，都会在输出文件中定义一个宏。而#cmakedfine则会根据变量在CMakeLists.txt中的定义情况来确定是否会在输出文件中定义宏。如果变量在CMakeLists.txt中没有定义或都已定义但是一个判断为假的布尔值，则不会在输出文件中定义对应的宏，如果变量在CMakeLists.txt中有定义且不为布尔值、或者为布尔值但判断为真，则会在输出文件中定义对应的宏。

用法示例：

```cmake
#cmakedefine USE_MYMATH
```



## 第三步 添加使用依赖

### 练习1 为库添加使用依赖

如果三方库过多，每个都要在主项目中添加include的路径（即APPEND EXTRA_INCLUDES，以及target_include_directories）过于麻烦，这些工作我们放在三方库的CMakeLists中，而主项目中仅APPEND EXTRA_LIBS以及target_link_libraries即可。

```cmake
CMakeLists.txt
cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the C++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# should we use our own math functions
option(USE_MYMATH "Use tutorial provided math implementation" ON)
message(STATUS "OUT --- ${CMAKE_CURRENT_SOURCE_DIR}")

# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)

# TODO 2: 删除EXTRA_INCLUDES

# add the MathFunctions library
if(USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)
endif()

# add the executable
add_executable(Tutorial tutorial.cxx)

target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})

# TODO 3: 删除EXTRA_INCLUDES

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           )
                           
                           
# MathFunctions/CMakeLists.txt即三方库中的CMakeLists文件
add_library(MathFunctions mysqrt.cxx)

# TODO 1: 声明所有需要链接MathFunctions库的都要在头文件搜索中加入当前当前目录，但是MathFunctions本身不需要
# Hint: 用target_include_directories和INTERFACE  
# PUBLIC 本目标需要用，依赖这个目标的其他目标也需要用
# INTERFACE  本目标不需要，依赖本目标的其他目标需要
# PRIVATE 本目标需要，依赖这个目标的其他目标不需要
target_include_directories(MathFunctions INTERFACE "${CMAKE_CURRENT_SOURCE_DIR}")
message(STATUS "MathFunction --- ${CMAKE_CURRENT_SOURCE_DIR}")
```

**要点**

①PUBLIC | INTERFACE | PRIVATE

在使用`target_include_directories`和`target_link_libraries`添加搜索目录时，有三个修饰符`PUBLIC | INTERFACE | PRIVATE`，其含义如下：

**PUBLIC**：当前目标和以当前目标为依赖的目标都能能使用添加的目录，都能在对应的目录中进行搜索

**PRIVATE**：只有当前目标能使用添加的目录，以当前目标为依赖的目标不能使用

**INTERFACE**：以当前目标为依赖的目标需要使用添加的目录，但当前目标不需要用这种方式添加对应搜索目录时用INTERFACE。

 

②CMAKE_CURRENT_SOURCE_DIR

变量。当前CMakeLists.txt所在的目录。



## 第四步 生成器表达式

### 练习1 用接口库设置C++标准

就是自己定义一个抽象的库，即接口库，仅用来设置规范相关的内容。

```cmake
CMakeLists.txt
# TODO 4: Update the minimum required version to 3.15

cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)

# TODO 1: 将下面的代码替换为:
# * 创建一个interface库tutorial_compiler_flags
#   Hint: use add_library() with the INTERFACE signature
# * 添加编译特性cxx_std_11到tutorial_compiler_flags
#   Hint: Use target_compile_features()
# 就是添加一个接口库用来管理项目的规范，如C++版本等。设计理念类似抽象接口类。
add_library(tutorial_compiler_flags INTERFACE)
target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_14)



# TODO 5: 创建一些辅助变量用来确定用的是哪个编译器:
# * 创建一个变量gcc_like_cxx如果用的是CXX并且用的是下列任意一个编译器那么值为true
#         ARMClang, AppleClang, Clang, GNU, LCC
# * 创建一个变量msvc_cxx如果用的是CXX和MSVC那么值为true
# Hint: Use set() and COMPILE_LANG_AND_ID

# TODO 6: 向interface库tutorial_compiler_flags中添加警告选项：
# 
# * 如果是gcc_like_cxx, 添加 -Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused
# * 如果是msvc_cxx, 添加 -W3
# Hint: Use target_compile_options()

# TODO 7: 用嵌套生成器表达式, 只在构建的时警告
# 
# Hint: Use BUILD_INTERFACE

# should we use our own math functions
option(USE_MYMATH "Use tutorial provided math implementation" ON)

# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)

# add the MathFunctions library
if(USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)
endif()

# add the executable
add_executable(Tutorial tutorial.cxx)

# TODO 2: 链接tutorial_compiler_flags

target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS} tutorial_compiler_flags)

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           )
                           
                           
# MathFunctions/CMakeLists.txt，即三方库目录下的CMakeLists文件
add_library(MathFunctions mysqrt.cxx)

# state that anybody linking to us needs to include the current source dir
# to find MathFunctions.h, while we don't.
target_include_directories(MathFunctions
          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
          )

# TODO 3: 链接tutorial_compiler_flags
# 将接口库链接到实体库
target_link_libraries(MathFunctions PUBLIC tutorial_compiler_flags)
```

**要点**

①INTERFACE库

使用`add_library(<libname> INTERFACE)`可以创建个Interface库，这样的库并不是真实存在的，是一个虚拟的库，通常用来传递一些选项。用法和正常的库一样，可通过`target_link_libraries`链接到目标，可以向指定的目标传递一些指定的参数选项。

 

②target_compile_features

`target_compile_features` 是 CMake 用来指定编译器特性的命令。它可以用来指定编译器需要支持的 C++ 标准或者其他编译器特性。具体支持的特性取决于编译器版本和 CMake 版本。

语法与示例

```cmake
target_compile_features(<target> <PRIVATE|PUBLIC|INTERFACE> <feature> [...])

# 示例
target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)
```

以下是一些常见的特性：

- `cxx_std_11`：指定 C++11 标准。
- `cxx_std_14`：指定 C++14 标准。
- `cxx_std_17`：指定 C++17 标准。
- `cxx_std_20`：指定 C++20 标准。
- `cxx_constexpr`：启用 C++11 constexpr 函数。
- `cxx_nullptr`：启用 C++11 nullptr 关键字。
- `cxx_auto_type`：启用 C++11 auto 关键字。
- `cxx_lambdas`：启用 C++11 lambda 表达式。
- `cxx_range_for`：启用 C++11 range-based for 循环。
- `cxx_override`：启用 C++11 override 关键字。
- `cxx_final`：启用 C++11 final 关键字。

 

### 练习2 添加编译警告选项

**CMakeLists.txt解析过程**

CMake构建过程分为两个阶段

1. 配置阶段，CMake 会读取项目的 CMakeLists.txt 文件，并根据其中的指令和参数来生成 Makefile 或者 IDE 的项目文件
   - 检查编译器和工具链是否可用，并设置编译器选项和链接选项
   - 检查系统库和第三方库是否可用，并设置库的路径和链接选项
   - 检查项目的源代码文件，并设置编译选项和链接选项
   - 生成 Makefile 或者 IDE 的项目文件
   - 根据不同的平台和编译器生成不同的 Makefile 或者项目文件，以保证项目可以在不同的平台和编译器上构建
2. 生成阶段，CMake 会根据配置阶段生成的 Makefile 或者项目文件来执行实际的构建操作
   - 根据 Makefile 或者项目文件中的指令和参数来编译源代码文件，并生成目标文件
   - 根据 Makefile 或者项目文件中的指令和参数来链接目标文件，并生成可执行文件或者库文件

 

**生成器表达式**

CMake生成器表达式是一种特殊的语法，用于在CMake构建系统中动态地生成构建规则。它们可以用于指定编译器选项、链接选项等。

本节先学习其中两种表达式：

`$<condition:true_string>`

- 如果`condition`为1，则此表达式结果为`true_string`
- 如果`condition`为0，则此表达式结果为空

`$<COMPILE_LANG_AND_ID:language,compiler_ids>`

- 如果当前所用的语言与`language`一致且编译器ID在`compiler_ids`的列表中，则表达式值为1，否则为0
- `language`值主要为`CXX`和`C`
- `compiler_ids`主要有GNU、Clang、MSVC等，有多个时用逗号隔开

生成器表达式因为是在生成阶段可用，所以不能在配置阶段进行输出 ，可用下面方式调式

```cmake
add_custom_target(ged COMMAND ${CMAKE_COMMAND} -E echo "$<1:hello>")
```

配置完成之后，用以下命令进行输出

```bash
cmake --build . --target ged
# 用make可简写
make ged
```

但不是所有的表达式都能这样输出，有的表达式无法输出，比如`$<COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC>`

 

```cmake
# TODO 4: Update the minimum required version to 3.15

cmake_minimum_required(VERSION 3.15)

# set the project name and version
project(Tutorial VERSION 1.0)

# TODO 1: 将下面的代码替换为:
# * 创建一个interface库tutorial_compiler_flags
#   Hint: use add_library() with the INTERFACE signature
# * 添加编译特性cxx_std_11到tutorial_compiler_flags
#   Hint: Use target_compile_features()
add_library(tutorial_compiler_flags INTERFACE)
target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_14)

# add_custom_target(ged COMMAND ${CMAKE_COMMAND} -E echo "$<COMPILE_LANG_AND_ID:CXX,GNU>")

# TODO 5: 创建一些辅助变量用来确定用的是哪个编译器:
# * 创建一个变量gcc_like_cxx如果用的是CXX并且用的是下列任意一个编译器那么值为true
#         ARMClang, AppleClang, Clang, GNU, LCC
# * 创建一个变量msvc_cxx如果用的是CXX和MSVC那么值为true
# Hint: Use set() and COMPILE_LANG_AND_ID
# 生成表达式会在make命令的时候生效；这两个变量在g++编译器中gcc_like_cxx为1，msvc_cxx为0
set(gcc_like_cxx "$<COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC>")
set(msvc_cxx "$<COMPILE_LANG_AND_ID:CXX,MSVC>")


# TODO 6: 向interface库tutorial_compiler_flags中添加警告选项：
# 
# * 如果是gcc_like_cxx, 添加 -Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused
# * 如果是msvc_cxx, 添加 -W3
# Hint: Use target_compile_options()
# 目标依旧选择之前构建的抽象库，再次说明，抽象库主要用来规范和配置，并没有实际程序用途
# 该语句意思为：为g++添加编译选项
target_compile_options(tutorial_compiler_flags INTERFACE 
  "$<${gcc_like_cxx}:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused>"
  "$<${msvc_cxx}:-W3>"
)

# TODO 7: 用嵌套生成器表达式, 只在构建的时警告
# 
# Hint: Use BUILD_INTERFACE

# should we use our own math functions
option(USE_MYMATH "Use tutorial provided math implementation" ON)

# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)

# add the MathFunctions library
if(USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)
endif()

# add the executable
add_executable(Tutorial tutorial.cxx)

# TODO 2: 链接tutorial_compiler_flags

target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS} tutorial_compiler_flags)

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           )
```

**要点**

①target_compile_options

给指定的目标添加编译选项。

语法及示例：

```cmake
target_compile_options(<target> [BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> [items1...]
  [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])

# 示例
target_compile_options(Tutorial PUBLIC -std=c++11 -Wunused)
```

 

## 第五步 安装与测试

### 练习1 安装规则

```cmake
CMakeLists.txt
cmake_minimum_required(VERSION 3.15)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the C++ standard
add_library(tutorial_compiler_flags INTERFACE)
target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)

# add compiler warning flags just when building this project via
# the BUILD_INTERFACE genex
set(gcc_like_cxx "$<COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC>")
set(msvc_cxx "$<COMPILE_LANG_AND_ID:CXX,MSVC>")
target_compile_options(tutorial_compiler_flags INTERFACE
  "$<${gcc_like_cxx}:$<BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused>>"
  "$<${msvc_cxx}:$<BUILD_INTERFACE:-W3>>"
)

# should we use our own math functions
option(USE_MYMATH "Use tutorial provided math implementation" ON)

# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)

# add the MathFunctions library
if(USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)
endif()

# add the executable
add_executable(Tutorial tutorial.cxx)
target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS} tutorial_compiler_flags)

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           )

# TODO 3: 安装 Tutorial 到 bin 目录  ${CMAKE_INSTALL_PREFIX}
# Hint: Use the TARGETS and DESTINATION parameters
# install(TARGETS targets... [DESTINATION <dir>])
# 该命令会将可执行文件安装到默认路劲下bin目录（如果没有会自动创建）
# 可以使用cmake -DCMAKE_INSTALL_PREFIX指定安装目录（类似原始的configure）
install(TARGETS Tutorial DESTINATION bin)
message(STATUS "${CMAKE_INSTALL_PREFIX}")

# TODO 4: 安装TutorialConfig.h到include目录
# Hint: Use the FILES and DESTINATION parameters
install(FILES "${PROJECT_BINARY_DIR}/TutorialConfig.h" DESTINATION include)


# MathFunctions/CMakeLists.txt，即三方库的目录
add_library(MathFunctions mysqrt.cxx)

target_include_directories(MathFunctions
          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
          )

target_link_libraries(MathFunctions tutorial_compiler_flags)
# 可以将三方库集合到一个变量中，方便安装
set(installable_libs MathFunctions tutorial_compiler_flags)
if(TARGET SqrtLibrary)
  list(APPEND installable_libs SqrtLibrary)
endif()
# 将库文件安装到默认目录下的lib中，注意，TARGET安装可以直接写在cmake中定义的三方库名
install(TARGETS ${installable_libs} DESTINATION lib)
# 将指定头文件安装到默认目录下的include中，注意，FILE需要写文件的全称（包括相对路径前缀）
install(FILES MathFunctions.h DESTINATION include)
```

**要点**

①if(TARGET target-name)

- 如果`target-name`是一个已经调用`add_executable`、`add_library`、`add_custom_target`创建的目标，则返回True

②install

用于定义安装规则。

语法与示例（简洁版）

```
# 安装生成的目标文件
install(TARGETS <目标名列表> DESTINATION <安装位置>)
# 安装其他文件
install(FILES <文件列表> DESTINATION <安装位置>)
```

安装多个文件时，用空格隔开。安装位置是相对于`CMAKE_INSTALL_PREFIX`的，`CMAKE_INSTALL_PREFIX`是安装时的默认路径，可以自行用`set`设置。

运行安装：

安装到默认路径下

```bash
cmake --install .
```

如果有多个生成版本，指定安装版本

```bash
cmake --install . --config Release
```

如果用的是IDE，用下列命令

```bash
cmake --build . --target install --config Debug
```

自行指定安装路径

```bash
cmake --install . --prefix "/path/to/your/installdir"
```

 

### 练习2 测试支持

`CTest`提供了一些测试管理。本节内容为给可执行文件创建单元测试。

```cmake
cmake_minimum_required(VERSION 3.15)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the C++ standard
add_library(tutorial_compiler_flags INTERFACE)
target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)

# add compiler warning flags just when building this project via
# the BUILD_INTERFACE genex
set(gcc_like_cxx "$<COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC>")
set(msvc_cxx "$<COMPILE_LANG_AND_ID:CXX,MSVC>")
target_compile_options(tutorial_compiler_flags INTERFACE
  "$<${gcc_like_cxx}:$<BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused>>"
  "$<${msvc_cxx}:$<BUILD_INTERFACE:-W3>>"
)

# should we use our own math functions
option(USE_MYMATH "Use tutorial provided math implementation" ON)

# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)

# add the MathFunctions library
if(USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)
endif()

# add the executable
add_executable(Tutorial tutorial.cxx)
target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS} tutorial_compiler_flags)

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           )

# TODO 3: 安装 Tutorial 到 bin 目录  ${CMAKE_INSTALL_PREFIX}
# Hint: Use the TARGETS and DESTINATION parameters
# install(TARGETS targets... [DESTINATION <dir>])
# target: add_excutable add_library
install(TARGETS Tutorial DESTINATION bin)
message(STATUS "${CMAKE_INSTALL_PREFIX}")

# TODO 4: 安装TutorialConfig.h到include目录
# Hint: Use the FILES and DESTINATION parameters
install(FILES "${PROJECT_BINARY_DIR}/TutorialConfig.h" DESTINATION include)

# TODO 5: Enable testing
# 开启测试
enable_testing()

# TODO 6: 添加一个Runs测试，运行下面的命令:
# 测试名称叫做Runs，执行的命令是：$ Tutorial 25
add_test(NAME Runs COMMAND Tutorial 25)

# TODO 7: 添加一个叫Usage的测试，执行下面的命令:
# Hint: 用PASS_REGULAR_EXPRESSION属性匹配"Usage.*number"
# 测试名为Usage，执行的命令为$ Tutorial
add_test(NAME Usage COMMAND Tutorial)
#如果满足测试属性，该测试才算通过。该用例是输出内容满足正则表达式"Usage.*number"即通过。
set_tests_properties(Usage PROPERTIES PASS_REGULAR_EXPRESSION "Usage.*number")

# TODO 8: 再添加一个运行下面命令的测试:
# $ Tutorial 4
# 保证输出结果是正确的.
# Hint: 用PASS_REGULAR_EXPRESSION属性匹配"4 is 2"
add_test(NAME Com4 COMMAND Tutorial 4)
set_tests_properties(Com4 PROPERTIES PASS_REGULAR_EXPRESSION "4 is 2")


# TODO 9: 添加更多测试. 创建一个函数do_test完成重复内容
# 测试以下数值: 4, 9, 5, 7, 25, -25 and 0.0001.
# 声明测试函数do_test,参数为num，result
function(do_test num result)
  add_test(NAME Com${num} COMMAND Tutorial ${num})
  set_tests_properties(Com${num} PROPERTIES PASS_REGULAR_EXPRESSION "${num} is ${result}")
endfunction()
# 调用函数
do_test(9 3)
do_test(5 2.236)
do_test(7 2.645)
do_test(-25 "(-nan|nan|0)") # not a number
do_test(0.0001 0.001)


# 5 2.236
# 7 2.645
# -25 "(-nan|nan|0)"
# 0.0001 0.001
# do_test(4 2)
```

**要点**

①enable_testing()

开启当前目录及子目录的测试支持。

②add_test

添加一条测试

简版用法：

```cmake
add_test(NAME <name> COMMAND <command> [<arg>...])
```

- `name`为本条测试名称
- `command`测试用的命令
- `arg`传递测试命令的参数

③set_tests_properties

设置测试的属性。

语法

```
set_tests_properties(test1 [test2...] PROPERTIES prop1 value1 prop2 value2)
```

- `test1...`为用add_test添加的测试名
- `prop1`为需要设置的属性名，本节中只学`PASS_REGULAR_EXPRESSION`，表示测试程序的输出结果需要能匹配`value`所表示的正则表达式才能通过，如果匹配不了则不通过。
- `value`要设置的属性值

示例

```cmake
set_tests_properties(Usage
  PROPERTIES PASS_REGULAR_EXPRESSION "Usage:.*number"
  )
```

表示运行`Usage`这个测试时测试程序的输出结果要能正则匹配到"Usage:.*number"。

④function()与endfunction()

用于在定义函数，分别表示函数开始与函数结束

语法

```cmake
function(<name> [<arg1> ...])
  <commands>
endfunction()
```

- 括号里第一个参数为函数名，后面是参数列表，可以有多个，多个参数用空格隔开

示例：

```cmake
# 定义
function(do_test target arg result)
  add_test(NAME Comp${arg} COMMAND ${target} ${arg})
  set_tests_properties(Comp${arg}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result}
    )
endfunction()

# 调用
do_test(Tutorial 4 "4 is 1")
```

 测试命令：

```bash
$cmake .. #配置
$ctest -N #输出有多少个测试
$ctest -VV #输出测试结果
```



## 第六步 添加测试面板支持

### 练习1 发送测试结果到测试面板

```cmake
CMakeLists.txt
# 将enable_testing()替换为下面这行
include(CTest)
```

在build目录执行

```bash
cmake -G "MinGW Makefiles" ..
```

之后执行

```bash
ctest -VV -D Experimental
```

即可。

完成之后可在[https://my.cdash.org/index.php?project=CMakeTutorial查看提交的测试结果。](https://gitee.com/link?target=https%3A%2F%2Fmy.cdash.org%2Findex.php%3Fproject%3DCMakeTutorial%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E3%80%82)

 

 

## 第七步 添加系统特性检查

### 练习1 评估依赖可用性

注意：源代码也要根据check_cxx_source_compiles以及target_compile_definitions中对应的宏，对代码进行更改

```cmake
# 所有修改都在MathFunctions/CMakeLists.txt
add_library(MathFunctions mysqrt.cxx)

# state that anybody linking to us needs to include the current source dir
# to find MathFunctions.h, while we don't.
target_include_directories(MathFunctions
          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
          )

# link our compiler flags interface library
target_link_libraries(MathFunctions tutorial_compiler_flags)

# TODO 1: Include CheckCXXSourceCompiles
# 添加cmake的模块文件
include(CheckCXXSourceCompiles)

# TODO 2:用check_cxx_source_compiles和简单C++代码检测
# 以下两个函数是否可用:
# * std::log ln
# * std::exp e^2
# 把结果存在HAVE_LOG 和 HAVE_EXP 中.

# Hint: Sample C++ code which uses log:
# #include <cmath>
# int main() {
#   std::log(1.0);
#   return 0;
# }


#检查std::log是否可用，结果存在HAVE_LOG变量中
check_cxx_source_compiles("
#include <cmath>
int main() {
  std::log(1.0);
  return 0;
}
" HAVE_LOG)

check_cxx_source_compiles("
#include <cmath>
int main() {
  std::exp(1.0);
  return 0;
}
" HAVE_EXP)

# TODO 3: 如果HAVE_LOG和HAVE_EXP为真, 添加预编译定义
# "HAVE_LOG"和"HAVE_EXP"到目标MathFunctions上.
#Hint: Use target_compile_definitions()
# target_compile_definitions相较于之前的configurefile命令好处是，生成的宏可以直接在cpp源代码中使用
if(HAVE_LOG AND HAVE_EXP)
    target_compile_definitions(MathFunctions PRIVATE "HAVE_LOG" "HAVE_EXP")
endif()



# install libs
set(installable_libs MathFunctions tutorial_compiler_flags)
install(TARGETS ${installable_libs} DESTINATION lib)
# install include headers
install(FILES MathFunctions.h DESTINATION include)
```

**要点**

①include

用于导入其他CMake文件或模块。

```cmake
include(<file|module> [OPTIONAL] [RESULT_VARIABLE <var>]
                      [NO_POLICY_SCOPE])
```

②check_cxx_source_compiles

检查给定的C++代码能不能编译及链接成可执行文件。通常用来检查当前环境中是否具有某些特性。

用法

```cmake
check_cxx_source_compiles(<code> <resultVar> [FAIL_REGEX <regex1> [<regex2>...]])
```

- `code`为需要检查的代码，需要包含`main`函数
- `resultVar`为检查结果，如果成功返回布尔真，否则返回布尔假
- `FAIL_REGEX`如果提供，则返回为假的结果需要能匹配上对应的正则表达式

③target_compile_definitions

为指定可执行文件及库文件这类目标添加编译器定义，用来控制代码中的条件编译。有点类似于`#cmakedefine`与`configure_file`的作用，但这两个操作的结果会生成一个文件再进行引用，而`target_compile_definitions`不会生成文件。

用法

```cmake
target_compile_definitions(<target>
  <INTERFACE|PUBLIC|PRIVATE> [items1...]
  [<INTERFACE|PUBLIC|PRIVATE> [items2...] ...])
```

示例

```cmake
target_compile_definitions(MathFunctions PRIVATE "HAVE_LOG" "HAVE_EXP")
```

 

 

## 第八步 添加自定义命令及用自定义命令生成文件

在Linux中，有许多的工具命令，例如`ls`、`mv`、`mkdir`等。在CMake项目中，可以用源代码写一些自定义小工具，然后在CMake中进行调用，来完成一些工作。

本节的内容为自定义一个`MakeTable`命令用来生成指定范围整数的平方根并保存到文件中，在计算的时候可以用这些已经计算好的值来辅助计算。

```cmake
MathFunctions/CMakeLists.txt
# 注意依赖的头文件也要加入
add_library(MathFunctions mysqrt.cxx Table.h)
# 添加一个可执行程序
add_executable(MakeTable MakeTable.cxx)
# 添加可执行命令
add_custom_command(
  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  COMMAND MakeTable ${CMAKE_CURRENT_BINARY_DIR}/Table.h
  DEPENDS MakeTable
)

# state that anybody linking to us needs to include the current source dir
# to find MathFunctions.h, while we don't.
target_include_directories(MathFunctions
          INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
          #Table.h头文件地址，因为是通过MakeTable生成在可执行文件目录下的
          PRIVATE ${CMAKE_CURRENT_BINARY_DIR} 
          )

# link our compiler flags interface library
target_link_libraries(MathFunctions tutorial_compiler_flags)

# does this system provide the log and exp functions?
include(CheckCXXSourceCompiles)
check_cxx_source_compiles("
  #include <cmath>
  int main() {
    std::log(1.0);
    return 0;
  }
" HAVE_LOG)
check_cxx_source_compiles("
  #include <cmath>
  int main() {
    std::exp(1.0);
    return 0;
  }
" HAVE_EXP)

# add compile definitions
if(HAVE_LOG AND HAVE_EXP)
  target_compile_definitions(MathFunctions
                             PRIVATE "HAVE_LOG" "HAVE_EXP")
endif()

# install libs
set(installable_libs MathFunctions tutorial_compiler_flags)
install(TARGETS ${installable_libs} DESTINATION lib)
# install include headers
install(FILES MathFunctions.h DESTINATION include)
```

**要点**

①add_custom_command

执行自定义指令。

简版用法

```cmake
add_custom_command(OUTPUT output1
                   COMMAND command1
                   DEPENDS depends)
```

- `OUTPUT`指定输出文件名
- `COMMAND`指定要执行的指令
- `DEPENDS`执行指令需要依赖的内容。如果是由`add_executable`或`add_library`添加的目标名，写这一条可以保证对应目标的生成。

 

 

## 第九步 打包安装程序

发布程序可以有多种形式，比如安装包、压缩包、源文件等。CMake也提供了打包程序`cpack`可将程序打包成多种形式。

只需要在顶层CMakelists.txt中添加以下代码

```cmake
include(InstallRequiredSystemLibraries)
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/License.txt")
set(CPACK_PACKAGE_VERSION_MAJOR "${Tutorial_VERSION_MAJOR}")
set(CPACK_PACKAGE_VERSION_MINOR "${Tutorial_VERSION_MINOR}")
set(CPACK_SOURCE_GENERATOR "TGZ")
include(CPack)
```

在项目构建完成之后，可以直接执行

```
cpack
```

在Windows上默认情况会打包成.exe文件，所以需要先安装一个exe打包程序NSIS(Null Soft Installer)

NSIS下载地址：[https://sourceforge.net/projects/nsis/](https://gitee.com/link?target=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fnsis%2F)

也可以指定生成器打包成对应的格式

```bash
cpack -G ZIP # 打包成ZIP
```

具体生成器各类可以通过`cpack --help`查看

对于多配置项目，可以指定打包配置

```bash
cpack -C Debug # 打包Debug版本
```

也可以打包源代码

```bash
cpack --config CPackSourceConfig.cmake
```

 

## 第十步 选择静态链接库或动态链接库

在add_library的时候是可以指定静态库或者动态库。也可以使用option对BUILD_SHARED_LIBS变量进行设置，让用户选择生成动态库还是静态库

```cmake
CMakeLists.txt
cmake_minimum_required(VERSION 3.15)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the C++ standard
add_library(tutorial_compiler_flags INTERFACE)
target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)

# add compiler warning flags just when building this project via
# the BUILD_INTERFACE genex
set(gcc_like_cxx "$<COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC>")
set(msvc_cxx "$<COMPILE_LANG_AND_ID:CXX,MSVC>")
target_compile_options(tutorial_compiler_flags INTERFACE
  "$<${gcc_like_cxx}:$<BUILD_INTERFACE:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused>>"
  "$<${msvc_cxx}:$<BUILD_INTERFACE:-W3>>"
)

# should we use our own math functions
option(USE_MYMATH "Use tutorial provided math implementation" ON)
# 这里可以选择最后生成动态库还是静态库
option(BUILD_SHARED_LIBS "Use Dynamic? " ON)

# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)

# 设置动态库输出路径，注意，需要在添加库目录add_subdirectory之前设置
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}") # .a .lib
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}") # .dll .exe
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}") # .so

# add the MathFunctions library
if(USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)
endif()

# add the executable
add_executable(Tutorial tutorial.cxx)
target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS} tutorial_compiler_flags)

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           )

# add the install targets
install(TARGETS Tutorial DESTINATION bin)
install(FILES "${PROJECT_BINARY_DIR}/TutorialConfig.h"
  DESTINATION include
  )

# enable testing
include(CTest)

# does the application run
add_test(NAME Runs COMMAND Tutorial 25)

# does the usage message work?
add_test(NAME Usage COMMAND Tutorial)
set_tests_properties(Usage
  PROPERTIES PASS_REGULAR_EXPRESSION "Usage:.*number"
  )

# define a function to simplify adding tests
function(do_test target arg result)
  add_test(NAME Comp${arg} COMMAND ${target} ${arg})
  set_tests_properties(Comp${arg}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result}
    )
endfunction()

# do a bunch of result based tests
do_test(Tutorial 4 "4 is 2")
do_test(Tutorial 9 "9 is 3")
do_test(Tutorial 5 "5 is 2.236")
do_test(Tutorial 7 "7 is 2.645")
do_test(Tutorial 25 "25 is 5")
do_test(Tutorial -25 "-25 is (-nan|nan|0)")
do_test(Tutorial 0.0001 "0.0001 is 0.01")

# setup installer
include(InstallRequiredSystemLibraries)
set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/License.txt")
set(CPACK_PACKAGE_VERSION_MAJOR "${Tutorial_VERSION_MAJOR}")
set(CPACK_PACKAGE_VERSION_MINOR "${Tutorial_VERSION_MINOR}")
set(CPACK_SOURCE_GENERATOR "TGZ")
include(CPack)
```

**要点**

①BUILD_SHARED_LIBS

全局为`add_library`设置库的生成类型。`ON`则生成动态链接库，`OFF`则生成静态链接库。

②CMAKE_ARCHIVE_OUTPUT_DIRECTORY

指定静态库文件的生成位置。

③CMAKE_RUNTIME_OUTPUT_DIRECTORY

指定执行文件的生成位置，包括可执行程序和Windows上动态库文件(.dll)

④CMAKE_LIBRARY_OUTPUT_DIRECTORY

非Windows平台上的生成的.so库文件

## CMake使用第三方库

```cmake
cmake_minimum_required(VERSION 3.10)
project(MyPro)
# 指定库的位置
set(MATH_DIR /path)

add_executable(myPro MyPro.cxx)

# 指定头文件位置以及库文件位置
target_include_dirctories(myPro PRIVATE "${MATH_DIR}/include")
target_link_dirctories(myPro PRIVATE "${MATH_DIR}/lib")

#指定需要链接的库
target_link_libraries(myPro PRIVATE ThirdParty)
```

# Docker

## Docker和虚拟机的区别

+ 虚拟机会通过Hypervisor(虚拟机管理系统，就是VMware,VirtualBox这些)，虚拟出网卡，cpu，内存等虚拟硬件，再在上面建立起虚拟机，每个虚拟机是独立的操作系统，有自己的系统内核
+ 容器则是利用**namespace**将文件系统，进程，网络，设备等资源进行隔离；利用**cgroup**对权限、cpu资源进行限制，最终可以使容器之间互不影响

## 容器的整体流程

+ 命名空间隔离：容器启动时，他的进程以及相关的资源都被置于独立的命名空间中，这样容器中的进程只能看到自己的命名空间，而不会感知到主机或者其他容器的存在
+ Cgroup控制：使用cgroup，哦容器的资源使用可以被限制和控制，例如可以限制容器使用的CPU百分比，内存量等。

## Docker的优势

> docker就相当于一个进程

+ 直接使用宿主机的硬件资源，因此在cpu、内存、利用率上，Docker将会在效率上有更大的优势
+ Docker直接利用宿主机的系统内核，避免了虚拟机启动时所需要的系统引导时间和操作系统运行的资源消耗，利用Docker可以在几秒钟之内启动大量的容器，是虚拟机无法半岛的。快速启动，低资源消耗的优点，使Docker在弹性云平台的自动运维系统方面具有很好的应用场景(结合K8s集群管理)
+ 容器的启动是秒级的，大量节约开发、测试、部署的时间。更关键的是，Docker可以更高效的部署和扩容，Docker几乎可以在任何平台运行，包括虚拟机、物理机、公有云、私有云、个人电脑、服务器等，这种兼容性，可以让用户把一个应用程序从一个平台直接迁移到另外一个平台
+ 但是，虚拟机的安全性比容器好一些，docker与宿主机共享内核、文件系统等资源，可能对其他容器和宿主机造成影响

## Docker的基本组成

> 相关概念：
>
> + 镜像：镜像类似于一个模板，或者说是容器的静态版本。镜像运行起来就是容器
> + 容器：可以简单理解成微型虚拟机，但是没有自己的资源，都依赖宿主机的资源。（类似进程与线程的关系）

+ 客户端
+ 服务器
+ 仓库：存储镜像文件

## Docker的常用命令

### 帮助命令：

```shell
docker version		# 显示docker版本信息
docker info			#显示docker的系统信息，包括镜像和容器的数量
docker 命令 --help   #帮助命令
```

### 镜像常用命令：

#### docker images：查看本地镜像

```shell
[root@test /]# docker images
RESPOSITORY		TAG		IMAGE ID		CREATED		SIZE
hello-world		latest	salskdfj		1 days ago	13.3kB

# 解释
RESPOSITORY 镜像的仓库源
TAG			镜像的标签
IMAGE ID	镜像ID
CREATED		镜像的创建时间
SIZE		镜像的大小

# 可选项
-a,--all	# 列出所有镜像
-q,--quiet	# 只显示镜像的id
```

#### docker search：搜索镜像

```shell
[root@test /]# docker search mysql
NAME	DESCRIPITION	STARS	OFFICIAL
mysql	...				9494	[OK]		
mariadb	...				3441	[OK]
...

# 可选项，过滤条件
--filter=STARS=3000 #搜索STARS大于3000的
# 示例
[root@test /]# docker search mysql --filter=STARS=3000
NAME	DESCRIPITION	STARS	OFFICIAL
mysql	...				9494	[OK]		
mariadb	...				3441	[OK]

[root@test /]# docker search mysql --filter=STARS=5000
NAME	DESCRIPITION	STARS	OFFICIAL
mysql	...				9494	[OK]		
```

#### docker pull:拉取镜像

```shell
# docker pull name[:tag=latest]
[root@test /]# docker pull mysql
using default tag:latest	# 默认tag为latest
...
Digest:sha256:...			# 签名
Status:Downloaded newer image for mysql:latest
docker.io/library/mysql:latest # 真实地址

# 以下命令等价
docker pull mysql
docker pull docker.io/library/mysql:latest
```

#### docker rmi:删除镜像

```shell
[root@test /]# docker rmi -f 容器ID
[root@test /]# docker rmi -f 容器ID 容器ID 容器ID
[root@test /]# docker rmi -f $(docker images -aq) #删除全部容器
```

#### docker tag：镜像打标签

```shell
# docker tag 镜像ID 命名容器
[root@test /]#docker tag docker.io/centos docker.io/centos:v1
```

### 容器常用命令

#### docker run:新建容器并启动

```shell
# docker run [param] image

#参数说明
--name=""	# 容器名称
-d			#	后台方式运行
-it			# 使用交互方式运行，进入容器查看内容
[root@test /]#docker run -it centos /bin/bash			#使用it交互方式打开centos镜像，使用/bin/bash解释命令

-p			# 指定容器端口 -p 8080:8080
	-p	ip:主机端口:容器端口
	-p	主机端口:容器端口（常用，即端口映射）
	-p	容器端口
	容器端口
-p			# 随机指定端口
```

#### docker ps：查看容器

```shell
# docker ps
-a		# 列出当前正在运行的容器+历史运行过的容器
-n=?	# 显示最近创建的容器
-q		# 只显示容器编号

#示例：
[root@test /]#docker ps
CONTAINER ID   IMAGE           COMMAND       CREATED      STATUS                  PORTS     NAMES

[root@test /]#docker ps -a
CONTAINER ID   IMAGE           COMMAND       CREATED      STATUS                  PORTS     NAMES
1157c35256ab   linux:monitor   "/bin/bash"   2 days ago   Exited (0) 2 days ago             linux_monitor
```

#### docker rm：删除容器

```shell
docker rm ID						# 删除指定容器，不能删除正在运行的容器，如果要强制删除，使用rm -f
docker -rm -f $(docker ps -aq)		# 删除所有容器	 
docker ps -a -q|xargs docker rm		# 删除所有容器
```

#### 启动和停止容器（类似服务）

```shell
docker start id		# 启动容器
docker restart id	# 重启容器
docker stop id		# 停止当前正在运行的容器
docker kill id		# 强制停止当前的容器

#	后台启动容器：docker run -d name
[root@test /]#docker run -d centos
#注意，docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止。（似乎可以使用screen解决？）
```

#### 进入后台运行的容器

```shell
# 方式一：docker exec -it id bashShell

[root@test /]#docker exec -it id /bin/bash    进入容器后开启一个/bin/bash的终端，可以在bash中操作（常用）

# 方式二：docker attach id
[root@test /]#docker attach id			进入程序正在执行的终端，不会启动新的进程
```

#### 日志相关

```shell
#docker logs -tf --tail n id
# -tf 显示日志
# --tail n 显示日志的条数

# 示例：
rosnoetic@rosnoetic-VirtualBox:~$ docker ps -a
CONTAINER ID   IMAGE           COMMAND       CREATED      STATUS                  PORTS     NAMES
1157c35256ab   linux:monitor   "/bin/bash"   2 days ago   Exited (0) 2 days ago             linux_monitor

rosnoetic@rosnoetic-VirtualBox:~$ docker logs -tf --tail 10 1157c35256ab
2024-03-08T07:50:31.928023507Z root@rosnoetic-VirtualBox:/# exit
```

#### 查看容器进程

```shell
# docker top id
[root@test /]#docker top id
UID		PID		PPID		C		STIME		TTY
```

#### 查看镜像的元数据

> 元数据：

```shell
# docker inspect id
[root@test /]#docker inspect id
```

#### 容器拷贝文件到宿主机

```shell
# docker cp id:docker_path host_path

# 示例：
[root@test /]#docker cp id:/home/test /home
```

#### 退出容器

```shell
exit		#容器停止并退出
ctrl+P+Q	#容器不停止并退出
```

### docker命令概述

```shell
attach		# 当前shell下依附指定运行镜像
build		# 通过Dockerfile定制镜像
commit		# 提交当前容器为新的镜像
cp			# 从容器中拷贝文件或目录到宿主机
create		# 创建一个新的容器，和run的区别是，仅创建，不启动,即run = create + start
diff		# 查看docker容器变化
events		# 从docker服务获取容器实时事件
exec		# 在已存在的容器上运行命令
export		# 到处容器的内容流作为一个tar归档文件  和import对应
history		# 展示一个镜像的历史记录
images		# 列出镜像
import		# 从tar包中的内容太创建一个新的文件系统
info		# 显示系统相关信息
inspect		# 查看容器的的底层信息
kill		# 关闭正在运行的容器
load		# 从一个tar包中加载一个镜像
login		# 注册或者登陆一个Docker注册（源）服务器
logout		# 从Docker注册（源）服务器中退出
logs		# 获取容器的日志
port		# 查看映射端口对应的容器内存源端口
pause		# 暂停容器内的所有进程
ps			# 列出容器
pull		# 从Docker注册（源）服务器拉去指定镜像或者仓库
push		# 推送指定镜像或者仓库到Docker注册（源）服务器
restart		# 重启运行中的容器
rm			# 移除一个或多个容器
rmi			# 移除一个或多个镜像（镜像需要使关闭状态，否则需要加-f）
run			# 在一个新容器中执行命令
save		# 保存一个镜像到tar包中
search		# 在Docker hub中搜索镜像
start		# 启动一个停止了的容器
stop		# 停止一个正在运行的容器
tag			# 将镜像打标签放入源（repository）中
top			# 查询容器中运行的进程
unpause		# 取消暂停容器
version		# 查看docker版本
wait		# 等待容器停止并且阻塞，然后输出退出代码(exit code)
```

## 容器数据卷

### 什么是数据卷

数据卷是一个虚拟目录，将宿主机目录映射到容器内目录，方便我们操作容器内的文件，或者方便迁移容器产生的数据  （本地目录<-----map--->数据卷<-----------map------->容器目录）

### 如何挂载数据卷

+ 在创建容器的时候，使用`-v 数据卷名:容器内目录`完成挂载

  > 该命令会在本地创建docker/volumns/数据卷名/_data,使得虚拟目录与本地目录相关联。由此，本地目录也和容器目录进行了间接的关联

+ 容器创建时，如果发现挂载的数据卷不存在时，会自动创建

### 数据卷常见命令

+ docker volume ls：查看数据卷
+ docker volume rm：删除数据卷
+ docker volume inspect：查看数据卷详情
+ docker volume prune：删除未使用的数据卷

> 卷技术也可以用来解决持久化的问题，即将容器中的目录挂载到本地目录下：
>
> + 在执行docker run 时，使用`-v 本地目录:容器目录`可以完成本地目录的挂载
> + 本地目录必须以"/"或"./"揩油，如果直接使用名称开头，会被识别为数据卷，而非本地目录。比如：
>   - -v mysql:/var/lib/mysql 会将容器目录映射到数据卷mysql中
>   - -v mysql:/var/lib/mysql 会将容器目录挂载到本地当前目录下的mysql目录中

利用数据卷可以实现宿主机与容器的双向映射。

## Dockerfile

> 通过dockerfile可以构建出所需的镜像，构建步骤：
>
> + 编写dockerfile文件
> + docker build 构建成为一个镜像
> + docker run 运行镜像
> + docker push 发布镜像

Dockerfile就相当于一层一层的构建镜像,dockerfile实例：

```dockerfile
FROM centos

VOLUME ["volume01","volume02"]

CMD echo "----end----"

CMD /bin/bash
```

通过dockerfile构建镜像的命令：

```shell
docker build -f /home/path/dockfile -t path/name:tag .
```

### dockerfile的编写

基础知识：

+ 每个保留关键字都必须是大写字母

+ 执行顺序从上到下

+ \#表示注释

+ 每一个指令都会创建一个新的镜像层，并提交。实例：

  > ​			可写容器(container)
  >
  > ​			镜像(tomcat)
  >
  > ​			镜像(jdk)
  >
  > ​			rootfs基础镜像(centos/ubuntu)
  >
  > ​			bootfs

dockerfile中的关键字：

```dockerfile
FROM			# 基础镜像，一切从这里开始构建
MAINTAINER		# 镜像作者，一般姓名+邮箱
RUN				# 镜像构建时需要运行的命令
ADD				# 添加内容：如压缩包
WORKDIR			# 进行的工作目录
VOLUME			# 挂载的目录
EXPOSE			# 保留端口配置
CMD				# 指定这个容器启动时候要运行的命令，仅最后一个生效，可以被覆盖
ENTRYPOINT		# 指定这个容器启动时候要运行的命令，可以追加命令
ONBUILD			# 当构建一个被继承的DockerFile，这个时候就会运行OMBUILD的指令。触发指令
COPY			# 类似ADD，将本地文件拷贝到镜像中
ENV				# 构建时候设置的环境变量
```

