> 该笔记记录工作中学习开发分布式性能监控项目中学习到的技能和知识点。

# Makefile

## 基础

makefile的三要素：依赖，目标，命令

```makefile
目标:依赖
	命令  //注意前面是tab
```

makefile支持增量编译,make会通过文件的时间戳判断是否需要进行增量编译以及对哪些文件进行增量编译

查看版本

```shell
make -v
```

简单示例：

```makefile
all:
	echo "Hello World"
```

执行结果：

```bash
$make
echo "Hello World"
Hello World

$make all
echo "Hello World"
Hello World

$make test
make: *** No rule to make target `test'. Stop.
```

可以为makefile加入test规则：

```makefile
all:
	echo "Hello World"
test:
	echo "Just for test!"
```

注意，make命令默认执行的是第一个规则，该示例中是all，但是对规则名称没有要求:

```bash
$make
echo "Hello World"
Hello World

$make test
echo "Just for test!"
Just for test!
```

我们可以对makefile做出更改，使得终端不输出执行的命令，。即在命令前加入`@`：

```makefile
all:
	@echo "Hello World"
test:
	@echo "Just for test!
```

```bash
$make
Hello World
```

再次更改makefile，使all依赖于test（该示例中，test也称之为all的*先决条件*）：

```makefile
all: test
	@echo "Hello World"
test:
	@echo "Just for test!"
```

```bash
$make
Just for test!
Hello World

$make test
Just for test!
```

对于规则，可以由多个目标名称，以空格隔开

```c++
all test:
	@echo "Hello World"
```

```bash
$make
Hello World

$make test
Hello World
```

### 简单应用：

**foo.c**:

```c
#include <stdio.h>
void foo ()
{
	printf ("This is foo   ()!\n");
}
```

**main.c**

```c
extern void foo();
int main ()
{
	foo();
	return 0;
}
```

**Makefile**

```makefile
all: main.o foo.o
	gcc -o simple main.o foo.o
main.o: main.c
	gcc -o main.o -c main.c
foo.o: foo.c
	gcc -o foo.o -c foo.c
clean:
	rm simple main.o foo.o
```

执行流程：

```bash
$make
gcc -c main.c -o main.o
gcc -c foo.c -o foo.o
gcc -o simple main.o foo.o

$./simple
This is foo ()!

$make clean
rm simple main.o foo.o
```

即使更改了规则的目标名，也不会影响makefile的增量编译：

```makefile
simple: main.o foo.o
	gcc -o simple main.o foo.o
main.o: main.c
	gcc -o main.o -c main.c
foo.o: foo.c
	gcc -o foo.o -c foo.c
clean:
	rm simple main.o foo.o
```

```bash
$make
gcc -c main.c -o main.o
gcc -c foo.c -o foo.o
gcc -o simple main.o foo.o

$make
make: `simple' is up to date.
```

### 假目标

加入touch了一个clean文件，在上述实例中，clean文件没有改变，make就永远不会像我们期待的那样执行rm指令。解决该问题的方法是使用**假目标**，即声明目标名并且加上`.PHONY:`,如：

```makefile
.PHONY: clean
simple: main.o foo.o
	gcc -o simple main.o foo.o
main.o: main.c
	gcc -o main.o -c main.c
foo.o: foo.c
	gcc -o foo.o -c foo.c
clean:
	rm simple main.o foo.o
```

### 变量

简单示例：

```makefile
.PHONY: clean
CC = gcc
RM = rm
EXE = simple
OBJS = main.o foo.o
$(EXE): $(OBJS)
	$(CC) -o $(EXE) $(OBJS)
main.o: main.c
	$(CC) -o main.o -c main.c
foo.o: foo.c
	$(CC) -o foo.o -c foo.c
clean:
	$(RM) $(EXE) $(OBJS)
```

变量的命名类似PYTHON，直接命名就可以。而变量的使用则是以`$(变量名)`的形式（类似预处理，直接替换文本）。

#### 自动变量

当目标或者依赖名称改变时，往往需要更改很多命令。对此，Makefile提供了自动变量(根据规则的上下文推导)：

- **$@**用于表示一个规则中的目标。当我们的一个规则中有多个目标时，$@所指的是其中**任何造成命令被运行的目标。**
- **$^**则表示的是规则中的所有先决条件。
- **$<**表示的是规则中的第一个先决条件。

需要注意的是，在 Makefile 中‘$’具有特殊的意思，因此，如果想采用 echo 输出‘$’，则必需用两个连着的‘$’。还有就是，$@对于 Shell 也有特殊的意思，我们需要在“$$@”之前再加一个脱字符‘\’。

简单示例：

```makefile
.PHONY: all
all: first second third
	@echo "\$$@ = $@"
	@echo "$$^ = $^"
	@echo "$$< = $<"
first second third:
```

```bash
$make
$@ = all				//目标
$^ = first second third	//依赖
$< = first				//首个依赖
```

对此可以对simple的makfile进行更改：

```c++
.PHONY: clean
CC = gcc
RM = rm
EXE = simple
OBJS = main.o foo.o
$(EXE): $(OBJS)
	$(CC) -o $@ $^				//原命令$(CC) -o $(EXE) $(OBJS)
main.o: main.c
	$(CC) -o $@ -c $^			//原命令：$(CC) -o main.o -c main.c
foo.o: foo.c
	$(CC) -o $@ -c $^			//原命令：$(CC) -o foo.o -c foo.c
clean:
	$(RM) $(EXE) $(OBJS)
```

#### 特殊变量

+ MAKE变量：代表make命令名，主要是为了增加可移植性

  ```makefile
  .PHONY: all
  all:
  	@echo "MAKE = $(MAKE)"
  ```

  ```bash
  $make
  MAKE = make
  ```

+ MAKECMDGOALS:make的目标名

  ```makefile
  Makefile
  .PHONY: all clean
  all clean:
      @echo "\$$@ = $@"
      @echo "MAKECMDGOALS = $(MAKECMDGOALS)"
  ```

  ```bash
  $make
  $@ = all
  MAKECMDGOALS =
  
  $make all
  $@ = all
  MAKECMDGOALS = all
  
  $make clean
  $@ = clean
  MAKECMDGOALS = clean
  
  $make all clean
  $@ = all
  MAKECMDGOALS = all clean
  $@ = clean
  MAKECMDGOALS = all clean
  ```

#### 变量类别

makefile提供了**递归扩展变量**的操作：

```makefile
.PHONY: all
foo = $(bar)
bar = $(ugh)
ugh = Huh?
all:
	@echo $(foo)
```

```bash
$make
Huh?
```

其实还是类似预处理的操作，核心还是变量的使用，需要注意的是防止死循环：

```makefile
CFLAGS = $(CFLAGS) -O	//死循环
```

同时makefile也提供了`:=`形式的**简单扩展变量**，这种形式的变量只会进行一次扫描和替换

```makefile
.PHONY: all
x = foo
y = $(x) b
x = later
xx := foo
yy := $(xx) b
xx := later
all:
	@echo "y = $(y), yy = $(yy)"
```

```bash
$make
y = later b, yy= foo b
```

最后makefile也提供了`?=`形式的条件赋值（即当前变量如果没有定义的话就进行赋值，否则无操作）：

```makefile
.PHONY: all
foo = x
foo ?= y
bar ?= y
all:
	@echo "foo = $(foo), bar = $(bar)"
```

```bash
$make
foo = x, bar = y
```

综上，我们可以书写可扩展，易读性强的makefile:

```makefile
.PHONY: all
objects = main.o foo.o bar.o utils.o
objects := $(objects) another.o
all:
	@echo $(objects)
```

```bash
$make
main.o foo.o bar.o utils.o another.o
```

#### 其他方式更改变量值

+ 执行make 并指定值，如:

  ```bash
  $make foo=haha
  foo = haha, bar = x
  ```

+ 通过export导入：

  ```bash
  $make
  foo = x, bar = y
  
  $export bar=x
  
  $make
  foo = x, bar = x
  ```

#### 高级变量引用功能

可以对变量赋值的同时完成后缀替换的操作。语法为`$(变量名:原后缀名=目标后缀名)`

```makefile
.PHONY: all
foo = a.o b.o c.o
bar := $(foo:.o=.c)
all:
	@echo "bar = $(bar)"
```

```bash
$make
bar = a.c b.c c.c
```

#### override

和C++中的override正好反过来，意思是这个变量不允许其他值覆盖：

```makefile
.PHONY: all
override foo = x
all:
	@echo "foo = $(foo)"
```

```bash
$make foo=haha
foo = x
```

### 模式

其实就是使用`%`作为通配符，如：

```makefile
.PHONY: clean
CC = gcc
RM = rm
EXE = simple
OBJS = main.o foo.o
$(EXE): $(OBJS)
	$(CC) -o $@ $^
%.o: %.c				//	main.o: main.c
	$(CC) -o $@ -c $^   //      gcc -o main.o -c main.c
                        //  foo.o: foo.c
                        //      gcc -o foo.o -c foo.c

clean:
	$(RM) $(EXE) $(OBJS)
```

### 函数

#### addprefix函数

为字符串中每个子串前加上一个前缀：`$(addprefix prefix,names...)`

```makefile
.PHONY: all
without_dir = foo.c bar.c main.o
with_dir := $( addprefix objs/, $(without_dir))
all:
	@echo $(with_dir)
```

```bash
$make
objs/foo.c objs/bar.c objs/main.o
```

#### filter函数

根据模式得到满足模式的字符串（简化正则）：`$(filter pattern...,text)`

```makefile
.PHONY: all
sources = foo.c bar.c baz.s ugh.h
sources := $(filter %.c %.s, $(sources))
all:
	@echo $(sources)
```

```bash
$make
foo.c bar.c baz.s		//可以看到过滤掉了.h文件
```

#### filter-out函数

过滤掉满足模式的字符串：`$(filter-out pattern...,text)`

```makefile
.PHONY: all
objects = main1.o foo.o main2.o bar.o
result = $(filter-out main%.o, $(objects))
all:
	@echo $(result)
```

```bash
$make
foo.o bar.o 	//过滤掉了满足main%.o模式的文件
```

#### patsubst 函数

根据模式进行字符串替换：`$(patsubst pattern,replacement,text)`

```makefile
.PHONY: all
mixed = foo.c bar.c main.o
objects := $(patsubst %.c, %.o, $(mixed))  # 将.c文件替换为.o文件
all:
	@echo $(objects)
```

```bash
$make
foo.o bar.o main.o
```

#### strip函数

去除字符串中多余空格：`$(strip string)`

```makefile
original = foo.c   bar.c
stripped := $(strip $(original))
all:
    @echo "original = $(original)"
    @echo "stripped = $(stripped)"
```

```bash
$make
original = foo.c   bar.c
stripped = foo.c bar.c
```

#### wildcard函数

通配符函数：`$(wildcard pattern)`

```makefile
.PHONY: all
SRCS = $(wildcard *.c)
all:
	@echo $(SRCS)
```

```bash
$make
bar.c foo.c main.c
```

# CMake

粗略的说，CMake就是生成编译配置文件，在Linux上就是生成makefile。

构建工程文件需要编写的是CMakeList.txt

## HelloWord

### 准备

```bash
mkdir cmake
cd cmake
mkdir t1
cd t1
vim main.c
```

**mian.c**

````c
#include <stdio.h>
int main()
{
printf(“Hello World from t1 Main!\n”); return 0;
}
````

```bash
vim CMakeLists.txt
```

```cmake
PROJECT (HELLO)
SET(SRC_LIST main.c)
MESSAGE(STATUS "This is BINARY dir " ${HELLO_BINARY_DIR})
MESSAGE(STATUS "This is SOURCE dir "${HELLO_SOURCE_DIR})
ADD_EXECUTABLE(hello SRC_LIST)
ADD_EXECUTABLE(hello2 SRC_LIST)
```

### 开始构建

```bash
$cmake .
 --  Check for working C compiler: /usr/bin/gcc
 --  Check for working C compiler: /usr/bin/gcc -- works
 --  Check size of void*
 --  Check size of void* - done
 --  Check for working CXX compiler: /usr/bin/c++
 --  Check for working CXX compiler: /usr/bin/c++ -- works
 --  This is BINARY dir cmake/t1
 --  This is SOURCE dir cmake/t1
 --  Configuring done
 --  Generating done
 --  Build files have been written to: cmake/t1
```

此时会发现自动生成了CMakeFiles,CmakeCache.txt,cmake_install.cmake等文件，并且身变成了Makefile

### 简单的解释

```cmake
PROJECT (HELLO)
SET(SRC_LIST main.c)
MESSAGE(STATUS "This is BINARY dir " ${HELLO_BINARY_DIR})
MESSAGE(STATUS "This is SOURCE dir "${HELLO_SOURCE_DIR})
ADD_EXECUTABLE(hello ${SRC_LIST})
```

#### PROJECT

语法：`PROJECT(name[CXX][C][Java])`

用来定义工程名称以及工程支持的语言，支持的语言可以忽略。这个指令隐式的定义了两个 cmake 变量: `<projectname>_BINARY_DIR` 以及`<projectname>_SOURCE_DIR`，这里就是 `HELLO_BINARY_DIR `和`HELLO_SOURCE_DIR`

同时cmake 系统也帮助我们预定义了 `PROJECT_BINARY_DIR` 和`PROJECT_SOURCE_DIR`变量，他们的值分别跟`HELLO_BINARY_DIR` 与`HELLO_SOURCE_DIR` 一致。

为了统一起见，建议以后直接使用`PROJECT_BINARY_DIR`，`PROJECT_SOURCE_DIR`，即使修改了工程名称，也不会影响这两个变量。如果使用了`<projectname>_SOURCE_DIR`，修改工程名称后，需要同时修改这些变量。

#### SET

语法：`SET(VAR [VALUE][CACHE TYPE DOCSTRING [FORCE]])`

设置变量，比如`SET(SRC_LIST main.c)`，如果有多个源文件，也可以定义成：

`SET(SRC_LIST main.c t1.c t2.c)`

#### MESSAGE

语法：`MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] "message to display" ...)`

这个指令用于向终端输出用户定义的信息，包含了三种类型: 

- SEND_ERROR，产生错误，生成过程被跳过。
- SATUS，输出前缀为—的信息。
- FATAL_ERROR，立即终止所有cmake 过程.

> 就和c++的oss差不多，加上可选的三个宏

#### ADD_EXECUTABLE 

命令：`ADD_EXECUTABLE(hello ${SRC_LIST})`

就是通过源文件生成一个可执行文件`hello`

所以上述CMakeLists.txt可以简化为：

```cmake
PROJECT(HELLO)
ADD_EXECUTABLE(hello main.c)
```

### 基本语法规则

+ 变量使用的是`${}`方式取值，但是在IF控制语句中直接使用变量名

+ 指令(参数1 参数2...)

  参数使用圆括号抱过，使用空格或者分号隔开。

  > 以上面的ADD_EXECUTABLE 指令为例，如果存在另外一个 func.c 源文件，就要写成：
  >
  > ADD_EXECUTABLE(hello main.c func.c)或者ADD_EXECUTABLE(hello main.c;func.c)

+ 指令大小不敏感，但是推荐指令大写

+ 清理工程：makefile会提工clean规则

+ 内部构建和外部构建：我们刚才进行的是内部构建(in-source build)，而 cmake 强烈推荐的是外部构建(out-of-source build)

  内部构建会将工程文件和生成文件都放在当前目录，所以更推荐外部构建(即之前使用三方库中的，创建单独的build目录)，本章实例可更改为：

  - 清除t1目录中除main.c CmakeLists.txt 之外的所有中间文件，最关键的是CMakeCache.txt
  - 在 t1 目录中建立build 目录,build的目录没有要求，只要在build目录执行cmake的时候指定工程目录（即CMakeLists.txt）所在目录即可
  - 进入 build 目录，运行cmake ..（注意这里的上级目录就是CMakeLists.txt的位置，需要根据实际更改）

  注意，不管内部构建还是外部构建，CMakeLists.txt中的工程源路径(`PROJECT_SOURCE_DIR `)是不变的,而可执行文件的路径则变成了build路径（该实例中，`PROJECT_BINARY_DIR`=cmake/t1/build）

## Better HelloWorld

#### 优化内容：

+ 为工程添加一个子目录src，用来放置工程源代码;

+ 添加一个子目录doc，用来放置这个工程的文档hello.txt

+ 在工程目录添加文本文件COPYRIGHT, README；

+ 在工程目录添加一个runhello.sh 脚本，用来调用hello 二进制

+ 将构建后的目标文件放入构建目录的bin 子目录；

+ 最终安装这些文件：将hello 二进制与runhello.sh 安装至/usr/bin，将doc 目录的内容以及COPYRIGHT/README 安装到/usr/share/doc/cmake/t2

#### 步骤

##### 添加子目录src存放工程源代码

```bash
$mkdir t2
$cp t1/main.c t2
$cp t1/CMakeLists.txt t2
$cd t2
$mkdir src
$mv main.c src
$cd src;vim CMakeLists.txt
```

```cmake
ADD_EXECUTABLE(hello main.c)		#src目录下的cmake文件
```

```
$cd ..;vim CMakeLists.txt
```

```cmake
 PROJECT(HELLO)
 ADD_SUBDIRECTORY(src bin)		#工程目录下的cmake文件，注意是添加子目录
```

```bash
$cd build;cmake ..;make
```

此时会发现hello文件位于build/bin目录下

> **ADD_SUBDIRECTORY**指令：
>
> 语法：`ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])`
>
> 该指令用来指明当前工程存放源文件的子目录，并且可以指定中间二进制和二进制存放的位置。
>
> EXCLUDE_FROM_ALL 参数的含义是**将这个目录从编译过程中排除**，比如，工程的 example，可能就需要工程构建完成后，再进入 example 目录单独进行构建。
>
> 上面的例子定义了将src 子目录加入工程，并指定编译输出(包含编译中间结果)路径为 bin 目录。如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在 build/src 目录(这个目录跟原有的src 目录对应)，指定 bin 目录后，相当于在编译时将src 重命名为bin，所有的中间结果和目标二进制都将存放在bin 目录。

##### 换个地方保存目标二进制文件

可以通过SET 指令重新定义`EXECUTABLE_OUTPUT_PATH `和`LIBRARY_OUTPUT_PATH` 变量来指定最终的目标二进制的位置(指最终生成的hello 或者最终的共享库，不包含编译生成的中间文件)，如：

```cmake
SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)	# 即build/bin
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)		# 即build/lib
```

指定输出路径应该写在哪一个CMakeLists应该遵循：在哪里ADD_EXECUTABLE 或ADD_LIBRARY，如果需要改变目标存放路径，就在哪里加入上述的定义

##### 安装(make install)

cmake提供了类似configure脚本的-prefix的变量：`CMAKE_INSTALL_PREFIX`

使用方法：

```bash
cmake -DCMAKE_INSTALL_PREFIX=/usr .
```

INSTALL指令：

```cmake
INSTALL(TARGETS targets...
[[ARCHIVE|LIBRARY|RUNTIME]
[DESTINATION <dir>]
[PERMISSIONS permissions...]
[CONFIGURATIONS
[Debug|Release|...]]
[COMPONENT <component>]
[OPTIONAL]
] [...])
```

参数中的TARGETS 后面跟的就是我们通过ADD_EXECUTABLE 或者ADD_LIBRARY 定义的目标文件，可能是可执行二进制、动态库、静态库

目标类型也就相对应的有三种，ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME特指可执行目标二进制。

DESTINATION 定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候 CMAKE_INSTALL_PREFIX 其实就无效了。如果你希望使用CMAKE_INSTALL_PREFIX 来定义安装路径，就要写成相对路径，即不要以/开头，那么安装后的路径就是 `${CMAKE_INSTALL_PREFIX}/<DESTINATION 定义的路径>`

简单的例子：

```cmake
INSTALL(TARGETS myrun mylib mystaticlib RUNTIME DESTINATION bin 
LIBRARY DESTINATION lib
ARCHIVE DESTINATION libstatic
)
```

上面的例子会将：

- 可执行二进制myrun 安装到${CMAKE_INSTALL_PREFIX}/bin 
- 目录动态库libmylib 安装到${CMAKE_INSTALL_PREFIX}/lib 目录
- 静态库libmystaticlib 安装到${CMAKE_INSTALL_PREFIX}/libstatic 目录

特别注意的是你不需要关心TARGETS 具体生成的路径，只需要写上TARGETS 名称就可以了。 

**对于普通文件的安装**

```cmake
INSTALL(FILES files... DESTINATION <dir> [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT <component>]
[RENAME <name>] [OPTIONAL])
```

可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限PERMISSIONS，安装后的权限为：OWNER_WRITE, OWNER_READ,   GROUP_READ,和WORLD_READ，即 644 权限。

**对于脚本文件的安装**

```cmake
INSTALL(PROGRAMS files... DESTINATION <dir>
[PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT <component>] [RENAME <name>] [OPTIONAL])
```

跟上面的FILES 指令使用方法一样，唯一的不同是安装后权限为:OWNER_EXECUTE, GROUP_EXECUTE, 和WORLD_EXECUTE，即755 权限目录的安装

**对目录的安装**

```cmake
INSTALL(DIRECTORY dirs... DESTINATION <dir> [FILE_PERMISSIONS permissions...] [DIRECTORY_PERMISSIONS permissions...]
[USE_SOURCE_PERMISSIONS] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT <component>]
[[PATTERN <pattern> | REGEX <regex>]
[EXCLUDE] [PERMISSIONS permissions...]] [...])
```

主要介绍其中的DIRECTORY、PATTERN 以及 PERMISSIONS 参数:

DIRECTORY 后面连接的是所在Source 目录的相对路径，但务必注意：abc 和 abc/有很大的区别。

 如果目录名不以/结尾，那么这个目录将被安装为目标路径下的abc，如果目录名以/结尾，代表将这个目录中的内容安装到目标路径，但不包括这个目录本身。

PATTERN 用于使用正则表达式进行过滤，PERMISSIONS 用于指定PATTERN 过滤后的文件权限。

##### 修改HelloWorld

首先添加需要补充的文件：

```bash
$mkdir doc
$vim doc/hello.txt	# 随便写
$vim runhello.sh	# hello
$touch COPYRIGHT
$touch README
```

下面改写CMakeLists.txt:

> 最终安装这些文件：将hello 二进制与runhello.sh 安装至`/<prefix>/bin`，将 doc 目录中的 hello.txt 以及COPYRIGHT/README 安装到`/<prefix>/share/doc/cmake/t2`，将

+ 安装COPYRIGHT/README,直接修改主工程文件CMakeLists.txt，加入指令：

  ```cmake
  INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/t2)
  ```

+ 安装 runhello.sh，直接修改主工程文件CMakeLists.txt，加入如下指令:

  ```cmake
  INSTALL(PROGRAMS runhello.sh DESTINATION bin)
  ```

+ 安装 doc 中的hello.txt:

  ```cmake
  INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake/t2)
  ```

**构建**

> CMAKE_INSTALL_PREFIX 的默认定义是/usr/local

```bash
$cd build;cmake -DCMAKE_INSTALL_PREFIX=/path ..
$make;make install
```

## 静态库与动态库构建



# Docker

## Docker和虚拟机的区别

+ 虚拟机会通过Hypervisor(虚拟机管理系统，就是VMware,VirtualBox这些)，虚拟出网卡，cpu，内存等虚拟硬件，再在上面建立起虚拟机，每个虚拟机是独立的操作系统，有自己的系统内核
+ 容器则是利用**namespace**将文件系统，进程，网络，设备等资源进行隔离；利用**cgroup**对权限、cpu资源进行限制，最终可以使容器之间互不影响

## 容器的整体流程

+ 命名空间隔离：容器启动时，他的进程以及相关的资源都被置于独立的命名空间中，这样容器中的进程只能看到自己的命名空间，而不会感知到主机或者其他容器的存在
+ Cgroup控制：使用cgroup，哦容器的资源使用可以被限制和控制，例如可以限制容器使用的CPU百分比，内存量等。

## Docker的优势

> docker就相当于一个进程

+ 直接使用宿主机的硬件资源，因此在cpu、内存、利用率上，Docker将会在效率上有更大的优势
+ Docker直接利用宿主机的系统内核，避免了虚拟机启动时所需要的系统引导时间和操作系统运行的资源消耗，利用Docker可以在几秒钟之内启动大量的容器，是虚拟机无法半岛的。快速启动，低资源消耗的优点，使Docker在弹性云平台的自动运维系统方面具有很好的应用场景(结合K8s集群管理)
+ 容器的启动是秒级的，大量节约开发、测试、部署的时间。更关键的是，Docker可以更高效的部署和扩容，Docker几乎可以在任何平台运行，包括虚拟机、物理机、公有云、私有云、个人电脑、服务器等，这种兼容性，可以让用户把一个应用程序从一个平台直接迁移到另外一个平台
+ 但是，虚拟机的安全性比容器好一些，docker与宿主机共享内核、文件系统等资源，可能对其他容器和宿主机造成影响

## Docker的基本组成

> 相关概念：
>
> + 镜像：镜像类似于一个模板，或者说是容器的静态版本。镜像运行起来就是容器
> + 容器：可以简单理解成微型虚拟机，但是没有自己的资源，都依赖宿主机的资源。（类似进程与线程的关系）

+ 客户端
+ 服务器
+ 仓库：存储镜像文件

## Docker的常用命令

### 帮助命令：

```shell
docker version		# 显示docker版本信息
docker info			#显示docker的系统信息，包括镜像和容器的数量
docker 命令 --help   #帮助命令
```

### 镜像常用命令：

#### docker images：查看本地镜像

```shell
[root@test /]# docker images
RESPOSITORY		TAG		IMAGE ID		CREATED		SIZE
hello-world		latest	salskdfj		1 days ago	13.3kB

# 解释
RESPOSITORY 镜像的仓库源
TAG			镜像的标签
IMAGE ID	镜像ID
CREATED		镜像的创建时间
SIZE		镜像的大小

# 可选项
-a,--all	# 列出所有镜像
-q,--quiet	# 只显示镜像的id
```

#### docker search：搜索镜像

```shell
[root@test /]# docker search mysql
NAME	DESCRIPITION	STARS	OFFICIAL
mysql	...				9494	[OK]		
mariadb	...				3441	[OK]
...

# 可选项，过滤条件
--filter=STARS=3000 #搜索STARS大于3000的
# 示例
[root@test /]# docker search mysql --filter=STARS=3000
NAME	DESCRIPITION	STARS	OFFICIAL
mysql	...				9494	[OK]		
mariadb	...				3441	[OK]

[root@test /]# docker search mysql --filter=STARS=5000
NAME	DESCRIPITION	STARS	OFFICIAL
mysql	...				9494	[OK]		
```

#### docker pull:拉取镜像

```shell
# docker pull name[:tag=latest]
[root@test /]# docker pull mysql
using default tag:latest	# 默认tag为latest
...
Digest:sha256:...			# 签名
Status:Downloaded newer image for mysql:latest
docker.io/library/mysql:latest # 真实地址

# 以下命令等价
docker pull mysql
docker pull docker.io/library/mysql:latest
```

#### docker rmi:删除镜像

```shell
[root@test /]# docker rmi -f 容器ID
[root@test /]# docker rmi -f 容器ID 容器ID 容器ID
[root@test /]# docker rmi -f $(docker images -aq) #删除全部容器
```

#### docker tag：镜像打标签

```shell
# docker tag 镜像ID 命名容器
[root@test /]#docker tag docker.io/centos docker.io/centos:v1
```

### 容器常用命令

#### docker run:新建容器并启动

```shell
# docker run [param] image

#参数说明
--name=""	# 容器名称
-d			#	后台方式运行
-it			# 使用交互方式运行，进入容器查看内容
[root@test /]#docker run -it centos /bin/bash			#使用it交互方式打开centos镜像，使用/bin/bash解释命令

-p			# 指定容器端口 -p 8080:8080
	-p	ip:主机端口:容器端口
	-p	主机端口:容器端口（常用，即端口映射）
	-p	容器端口
	容器端口
-p			# 随机指定端口
```

#### docker ps：查看容器

```shell
# docker ps
-a		# 列出当前正在运行的容器+历史运行过的容器
-n=?	# 显示最近创建的容器
-q		# 只显示容器编号

#示例：
[root@test /]#docker ps
CONTAINER ID   IMAGE           COMMAND       CREATED      STATUS                  PORTS     NAMES

[root@test /]#docker ps -a
CONTAINER ID   IMAGE           COMMAND       CREATED      STATUS                  PORTS     NAMES
1157c35256ab   linux:monitor   "/bin/bash"   2 days ago   Exited (0) 2 days ago             linux_monitor
```

#### docker rm：删除容器

```shell
docker rm ID						# 删除指定容器，不能删除正在运行的容器，如果要强制删除，使用rm -f
docker -rm -f $(docker ps -aq)		# 删除所有容器	 
docker ps -a -q|xargs docker rm		# 删除所有容器
```

#### 启动和停止容器（类似服务）

```shell
docker start id		# 启动容器
docker restart id	# 重启容器
docker stop id		# 停止当前正在运行的容器
docker kill id		# 强制停止当前的容器

#	后台启动容器：docker run -d name
[root@test /]#docker run -d centos
#注意，docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止。（似乎可以使用screen解决？）
```

#### 进入后台运行的容器

```shell
# 方式一：docker exec -it id bashShell

[root@test /]#docker exec -it id /bin/bash    进入容器后开启一个/bin/bash的终端，可以在bash中操作（常用）

# 方式二：docker attach id
[root@test /]#docker attach id			进入程序正在执行的终端，不会启动新的进程
```

#### 日志相关

```shell
#docker logs -tf --tail n id
# -tf 显示日志
# --tail n 显示日志的条数

# 示例：
rosnoetic@rosnoetic-VirtualBox:~$ docker ps -a
CONTAINER ID   IMAGE           COMMAND       CREATED      STATUS                  PORTS     NAMES
1157c35256ab   linux:monitor   "/bin/bash"   2 days ago   Exited (0) 2 days ago             linux_monitor

rosnoetic@rosnoetic-VirtualBox:~$ docker logs -tf --tail 10 1157c35256ab
2024-03-08T07:50:31.928023507Z root@rosnoetic-VirtualBox:/# exit
```

#### 查看容器进程

```shell
# docker top id
[root@test /]#docker top id
UID		PID		PPID		C		STIME		TTY
```

#### 查看镜像的元数据

> 元数据：

```shell
# docker inspect id
[root@test /]#docker inspect id
```

#### 容器拷贝文件到宿主机

```shell
# docker cp id:docker_path host_path

# 示例：
[root@test /]#docker cp id:/home/test /home
```

#### 退出容器

```shell
exit		#容器停止并退出
ctrl+P+Q	#容器不停止并退出
```

### docker命令概述

```shell
attach		# 当前shell下依附指定运行镜像
build		# 通过Dockerfile定制镜像
commit		# 提交当前容器为新的镜像
cp			# 从容器中拷贝文件或目录到宿主机
create		# 创建一个新的容器，和run的区别是，仅创建，不启动,即run = create + start
diff		# 查看docker容器变化
events		# 从docker服务获取容器实时事件
exec		# 在已存在的容器上运行命令
export		# 到处容器的内容流作为一个tar归档文件  和import对应
history		# 展示一个镜像的历史记录
images		# 列出镜像
import		# 从tar包中的内容太创建一个新的文件系统
info		# 显示系统相关信息
inspect		# 查看容器的的底层信息
kill		# 关闭正在运行的容器
load		# 从一个tar包中加载一个镜像
login		# 注册或者登陆一个Docker注册（源）服务器
logout		# 从Docker注册（源）服务器中退出
logs		# 获取容器的日志
port		# 查看映射端口对应的容器内存源端口
pause		# 暂停容器内的所有进程
ps			# 列出容器
pull		# 从Docker注册（源）服务器拉去指定镜像或者仓库
push		# 推送指定镜像或者仓库到Docker注册（源）服务器
restart		# 重启运行中的容器
rm			# 移除一个或多个容器
rmi			# 移除一个或多个镜像（镜像需要使关闭状态，否则需要加-f）
run			# 在一个新容器中执行命令
save		# 保存一个镜像到tar包中
search		# 在Docker hub中搜索镜像
start		# 启动一个停止了的容器
stop		# 停止一个正在运行的容器
tag			# 将镜像打标签放入源（repository）中
top			# 查询容器中运行的进程
unpause		# 取消暂停容器
version		# 查看docker版本
wait		# 等待容器停止并且阻塞，然后输出退出代码(exit code)
```

## 容器数据卷

### 什么是数据卷

数据卷是一个虚拟目录，将宿主机目录映射到容器内目录，方便我们操作容器内的文件，或者方便迁移容器产生的数据  （本地目录<-----map--->数据卷<-----------map------->容器目录）

### 如何挂载数据卷

+ 在创建容器的时候，使用`-v 数据卷名:容器内目录`完成挂载

  > 该命令会在本地创建docker/volumns/数据卷名/_data,使得虚拟目录与本地目录相关联。由此，本地目录也和容器目录进行了间接的关联

+ 容器创建时，如果发现挂载的数据卷不存在时，会自动创建

### 数据卷常见命令

+ docker volume ls：查看数据卷
+ docker volume rm：删除数据卷
+ docker volume inspect：查看数据卷详情
+ docker volume prune：删除未使用的数据卷

> 卷技术也可以用来解决持久化的问题，即将容器中的目录挂载到本地目录下：
>
> + 在执行docker run 时，使用`-v 本地目录:容器目录`可以完成本地目录的挂载
> + 本地目录必须以"/"或"./"揩油，如果直接使用名称开头，会被识别为数据卷，而非本地目录。比如：
>   - -v mysql:/var/lib/mysql 会将容器目录映射到数据卷mysql中
>   - -v mysql:/var/lib/mysql 会将容器目录挂载到本地当前目录下的mysql目录中

利用数据卷可以实现宿主机与容器的双向映射。

## Dockerfile

> 通过dockerfile可以构建出所需的镜像，构建步骤：
>
> + 编写dockerfile文件
> + docker build 构建成为一个镜像
> + docker run 运行镜像
> + docker push 发布镜像

Dockerfile就相当于一层一层的构建镜像,dockerfile实例：

```dockerfile
FROM centos

VOLUME ["volume01","volume02"]

CMD echo "----end----"

CMD /bin/bash
```

通过dockerfile构建镜像的命令：

```shell
docker build -f /home/path/dockfile -t path/name:tag .
```

### dockerfile的编写

基础知识：

+ 每个保留关键字都必须是大写字母

+ 执行顺序从上到下

+ \#表示注释

+ 每一个指令都会创建一个新的镜像层，并提交。实例：

  > ​			可写容器(container)
  >
  > ​			镜像(tomcat)
  >
  > ​			镜像(jdk)
  >
  > ​			rootfs基础镜像(centos/ubuntu)
  >
  > ​			bootfs

dockerfile中的关键字：

```dockerfile
FROM			# 基础镜像，一切从这里开始构建
MAINTAINER		# 镜像作者，一般姓名+邮箱
RUN				# 镜像构建时需要运行的命令
ADD				# 添加内容：如压缩包
WORKDIR			# 进行的工作目录
VOLUME			# 挂载的目录
EXPOSE			# 保留端口配置
CMD				# 指定这个容器启动时候要运行的命令，仅最后一个生效，可以被覆盖
ENTRYPOINT		# 指定这个容器启动时候要运行的命令，可以追加命令
ONBUILD			# 当构建一个被继承的DockerFile，这个时候就会运行OMBUILD的指令。触发指令
COPY			# 类似ADD，将本地文件拷贝到镜像中
ENV				# 构建时候设置的环境变量
```

